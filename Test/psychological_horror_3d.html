<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>The Bedroom</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Share+Tech+Mono&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
* { -webkit-tap-highlight-color: transparent; }
body { overflow: hidden; background: #000; cursor: none; font-family: 'Share Tech Mono', 'Courier New', monospace; touch-action: manipulation; }
canvas { display: block; }

/* ── Overlay / Main Menu ── */
#overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: #000; z-index: 100; cursor: default;
    transition: opacity 2s;
    overflow: hidden;
}

/* ambient particle canvas */
#menu-canvas {
    position: absolute; inset: 0; z-index: 0; pointer-events: none;
}

/* radial blood fog */
#overlay::before {
    content: '';
    position: absolute; inset: 0; z-index: 0; pointer-events: none;
    background: radial-gradient(ellipse 70% 55% at 50% 55%, rgba(80,0,0,0.18) 0%, transparent 70%);
    animation: pulse-glow 5s ease-in-out infinite alternate;
}
@keyframes pulse-glow {
    from { opacity: 0.6; }
    to   { opacity: 1; }
}

/* scanlines */
#overlay::after {
    content: '';
    position: absolute; inset: 0; z-index: 1; pointer-events: none;
    background: repeating-linear-gradient(
        to bottom,
        transparent 0px, transparent 3px,
        rgba(0,0,0,0.12) 3px, rgba(0,0,0,0.12) 4px
    );
}

#overlay > *:not(#menu-canvas) { position: relative; z-index: 2; }

/* ── Title ── */
#overlay h1 {
    font-family: 'Cinzel Decorative', cursive;
    color: #c0a090;
    font-size: clamp(28px, 5.5vw, 60px);
    letter-spacing: 10px;
    text-transform: uppercase;
    margin-bottom: 6px;
    text-shadow: 0 0 40px rgba(140,0,0,0.6), 0 0 80px rgba(100,0,0,0.3);
    animation: flicker 4s infinite, drift-in 1.2s cubic-bezier(0.23,1,0.32,1) both;
}

.title-rule {
    width: 260px; height: 1px;
    background: linear-gradient(to right, transparent, #6a0000, transparent);
    margin-bottom: 12px;
    animation: drift-in 1.4s cubic-bezier(0.23,1,0.32,1) both;
}

#overlay > p:not(.warning):not(#progress-text) {
    font-family: 'IM Fell English', serif;
    font-style: italic;
    color: #5a4a3a;
    font-size: 13px;
    letter-spacing: 3px;
    margin-bottom: 42px;
    animation: drift-in 1.6s cubic-bezier(0.23,1,0.32,1) both;
}

@keyframes drift-in {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0); }
}

/* ── ENTER button ── */
#overlay .start-btn {
    position: relative;
    font-family: 'Cinzel Decorative', cursive;
    color: #a09080;
    font-size: 14px;
    padding: 18px 64px;
    border: 1px solid rgba(100,0,0,0.4);
    background: transparent;
    cursor: pointer;
    letter-spacing: 6px;
    text-transform: uppercase;
    overflow: hidden;
    transition: color 0.4s, border-color 0.4s, text-shadow 0.4s;
    animation: drift-in 1.8s cubic-bezier(0.23,1,0.32,1) both;
}

/* blood fill sweep */
#overlay .start-btn::before {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(135deg, rgba(90,0,0,0.55), rgba(50,0,0,0.75));
    transform: translateX(-105%);
    transition: transform 0.55s cubic-bezier(0.23,1,0.32,1);
    z-index: 0;
}
/* glow underline */
#overlay .start-btn::after {
    content: '';
    position: absolute; bottom: 0; left: 10%; right: 10%; height: 1px;
    background: #8a0000;
    transform: scaleX(0);
    transition: transform 0.4s ease;
    box-shadow: 0 0 10px 2px rgba(180,0,0,0.6);
}
#overlay .start-btn span { position: relative; z-index: 1; }

#overlay .start-btn:hover {
    color: #fff;
    border-color: #9a0000;
    text-shadow: 0 0 20px rgba(255,80,80,0.45);
}
#overlay .start-btn:hover::before { transform: translateX(0); }
#overlay .start-btn:hover::after  { transform: scaleX(1); }

/* corner accents */
#overlay .start-btn .c {
    position: absolute; width: 7px; height: 7px;
    border-color: rgba(120,0,0,0.5); border-style: solid;
    transition: border-color 0.3s, width 0.3s, height 0.3s;
}
#overlay .start-btn .c.tl { top:4px; left:4px;   border-width:1px 0 0 1px; }
#overlay .start-btn .c.tr { top:4px; right:4px;  border-width:1px 1px 0 0; }
#overlay .start-btn .c.bl { bottom:4px; left:4px;  border-width:0 0 1px 1px; }
#overlay .start-btn .c.br { bottom:4px; right:4px; border-width:0 1px 1px 0; }
#overlay .start-btn:hover .c { border-color: #cc2222; width: 10px; height: 10px; }

/* ── Menu row ── */
#overlay .menu-row {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-top: 14px;
    animation: drift-in 2s cubic-bezier(0.23,1,0.32,1) both;
}

/* ── SETTINGS button ── */
#overlay .menu-btn {
    position: relative;
    font-family: 'Share Tech Mono', monospace;
    color: #555;
    font-size: 10px;
    padding: 10px 24px;
    border: 1px solid #1e1e1e;
    background: transparent;
    cursor: pointer;
    letter-spacing: 3px;
    text-transform: uppercase;
    overflow: hidden;
    transition: color 0.35s, border-color 0.35s;
}
/* left edge accent */
#overlay .menu-btn::before {
    content: '';
    position: absolute; top: 0; left: 0; width: 2px; height: 100%;
    background: #7a0000;
    transform: scaleY(0); transform-origin: bottom;
    transition: transform 0.3s ease;
}
/* underline sweep */
#overlay .menu-btn::after {
    content: '';
    position: absolute; bottom: 0; left: 0; right: 0; height: 1px;
    background: linear-gradient(to right, transparent, #6a0000, transparent);
    transform: scaleX(0);
    transition: transform 0.4s ease 0.05s;
}
#overlay .menu-btn:hover { color: #ccc; border-color: #444; }
#overlay .menu-btn:hover::before { transform: scaleY(1); }
#overlay .menu-btn:hover::after  { transform: scaleX(1); }
#overlay .menu-btn.nightmare-btn {
    color: #a05757;
    border-color: #3a1414;
}
#overlay .menu-btn.nightmare-btn:hover {
    color: #ffd4d4;
    border-color: #a02020;
}

/* ── Settings panel ── */
#settings-menu {
    margin-top: 18px;
    width: 340px;
    border: 1px solid #1a1a1a;
    border-top: 1px solid rgba(100,0,0,0.35);
    background: rgba(4, 2, 2, 0.97);
    color: #777;
    padding: 18px 20px;
    display: none;
    animation: drift-in 0.4s ease both;
}
#endings-menu {
    margin-top: 18px;
    width: 380px;
    border: 1px solid #1a1a1a;
    border-top: 1px solid rgba(100,0,0,0.35);
    background: rgba(4, 2, 2, 0.97);
    color: #777;
    padding: 20px;
    display: none;
    animation: drift-in 0.4s ease both;
    max-height: 450px;
    overflow-y: auto;
}
#endings-menu h3 {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing: 4px;
    color: #6a0000;
    margin-bottom: 20px;
    text-transform: uppercase;
    border-bottom: 1px solid #181818;
    padding-bottom: 10px;
}
.ending-entry {
    margin-bottom: 15px;
    padding: 10px;
    border: 1px solid #151515;
    background: rgba(10,10,10,0.5);
    transition: all 0.3s;
}
.ending-entry.locked { opacity: 0.3; filter: grayscale(1); }
.ending-entry.unlocked { border-color: #333; background: rgba(20,20,20,0.8); }
.ending-title {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
}
.unlocked .ending-title { color: #cc0000; }
.ending-desc { font-size: 9px; color: #555; line-height: 1.4; }
.unlocked .ending-desc { color: #999; }
.ending-hint { font-size: 8px; color: #444; font-style: italic; margin-top: 4px; }
#settings-menu h3 {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 4px;
    color: #6a0000;
    margin-bottom: 16px;
    text-transform: uppercase;
    border-bottom: 1px solid #181818;
    padding-bottom: 10px;
}
#settings-menu .setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 10px;
    letter-spacing: 1px;
    margin-bottom: 14px;
    color: #555;
}
#settings-menu .setting-row:last-child { margin-bottom: 0; }

/* range slider */
#settings-menu input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%; height: 2px;
    background: #1e1e1e;
    outline: none;
    margin-top: 8px;
}
#settings-menu input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    background: #7a0000;
    border-radius: 0;
    cursor: pointer;
    box-shadow: 0 0 6px rgba(150,0,0,0.5);
    transition: background 0.2s;
}
#settings-menu input[type="range"]::-webkit-slider-thumb:hover { background: #cc0000; }

/* checkbox */
#settings-menu input[type="checkbox"] {
    -webkit-appearance: none;
    appearance: none;
    width: 13px; height: 13px;
    border: 1px solid #3a3a3a;
    background: transparent;
    cursor: pointer;
    position: relative;
    transition: border-color 0.2s;
}
#settings-menu input[type="checkbox"]:checked { border-color: #7a0000; background: rgba(100,0,0,0.25); }
#settings-menu input[type="checkbox"]:checked::after {
    content: '✕';
    position: absolute; top: -2px; left: 1px;
    font-size: 10px; color: #cc0000;
}
.quality-btn {
    flex: 1;
    padding: 5px 0;
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    letter-spacing: 1px;
    color: #555;
    background: rgba(20,20,20,0.9);
    border: 1px solid #2a2a2a;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
}
.quality-btn:hover { color: #999; border-color: #444; }
.quality-btn.selected {
    color: #cc0000;
    border-color: #7a0000;
    background: rgba(100,0,0,0.15);
    box-shadow: 0 0 6px rgba(150,0,0,0.3);
}

/* ── Warning / Progress ── */
#overlay .warning {
    font-family: 'Share Tech Mono', monospace;
    color: #252020;
    font-size: 9px;
    letter-spacing: 2px;
    margin-top: 30px;
    animation: drift-in 2.2s cubic-bezier(0.23,1,0.32,1) both;
}
#progress-text {
    font-family: 'Share Tech Mono', monospace;
    color: #3a2a2a;
    margin-top: 8px;
    margin-bottom: 0;
    font-size: 10px;
    letter-spacing: 2px;
}

#loading-panel {
    display: none;
    width: min(440px, 86vw);
    margin-top: 18px;
    align-items: center;
    flex-direction: column;
    gap: 10px;
}
#overlay.loading-active #loading-panel {
    display: flex;
    animation: drift-in 0.45s ease both;
}
#overlay.loading-active > h1,
#overlay.loading-active > .title-rule,
#overlay.loading-active > p:not(.warning):not(#progress-text),
#overlay.loading-active > .start-btn,
#overlay.loading-active > .menu-row,
#overlay.loading-active > #settings-menu,
#overlay.loading-active > .warning,
#overlay.loading-active > #progress-text {
    opacity: 0;
    pointer-events: none;
}
#loading-stage {
    color: #7e6b64;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
}
#loading-bar-track {
    width: 100%;
    height: 12px;
    border: 1px solid rgba(110, 30, 30, 0.7);
    background: rgba(0, 0, 0, 0.52);
    box-shadow: inset 0 0 18px rgba(90, 0, 0, 0.42);
    overflow: hidden;
}
#loading-bar-fill {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #3e0000 0%, #7e1313 65%, #b33535 100%);
    transition: width 0.18s linear;
}
#loading-percent {
    font-size: 11px;
    color: #9a7a73;
    letter-spacing: 2px;
}
#loading-skip-btn {
    padding: 9px 18px;
    color: #887f7f;
    border-color: #332828;
}
#loading-skip-btn:hover {
    color: #fff;
    border-color: #7a2020;
}

/* ── Flicker ── */
@keyframes flicker {
    0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; }
    20%, 24%, 55% { opacity: 0.35; }
    22% { opacity: 0.9; }
}

@keyframes dialogueFadeIn {
    from { opacity: 0; transform: translateX(-50%) translateY(8px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

#vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 30;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.8) 100%);
}

#static-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 35; opacity: 0;
    background: repeating-linear-gradient(
        0deg, transparent, transparent 2px,
        rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px
    );
    mix-blend-mode: overlay;
}

#blood-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 32; opacity: 0;
    background: radial-gradient(ellipse at center, transparent 30%, rgba(80,0,0,0.4) 100%);
}

#red-flash-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 33; opacity: 0;
    box-shadow: inset 0 0 120px 40px rgba(255,0,0,0.8);
    transition: opacity 0.1s ease-out;
}
body.photosensitive-safe #red-flash-overlay {
    box-shadow: inset 0 0 95px 26px rgba(255,0,0,0.22);
}

#flash {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 60; opacity: 0; background: #fff;
}

#sleep-fade {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 65; opacity: 0; background: #000;
    transition: opacity 1.8s ease;
}

#battery-hud {
    position: fixed;
    right: 18px;
    bottom: 18px;
    z-index: 42;
    display: none;
    color: rgba(225, 235, 255, 0.92);
    border: 1px solid rgba(170, 190, 230, 0.35);
    background: rgba(0, 0, 0, 0.45);
    padding: 6px 9px;
    font-size: 11px;
    letter-spacing: 1px;
    text-transform: uppercase;
}
#battery-hud.low {
    color: rgba(255, 120, 120, 0.95);
    border-color: rgba(170, 40, 40, 0.7);
    text-shadow: 0 0 8px rgba(170, 40, 40, 0.6);
}

/* Mobile controls */
#mobile-controls {
    position: fixed;
    inset: 0;
    z-index: 70;
    display: none;
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}
body.mobile-mode #mobile-controls {
    display: block;
}
#mobile-controls.active {
    pointer-events: auto;
}
#mobile-left-pad,
#mobile-right-pad {
    position: absolute;
    bottom: 18px;
    width: min(38vw, 168px);
    height: min(38vw, 168px);
    border-radius: 50%;
    border: 1px solid rgba(170, 170, 170, 0.22);
    background: radial-gradient(circle at 35% 35%, rgba(120,120,120,0.22), rgba(0,0,0,0.45));
    box-shadow: inset 0 0 25px rgba(0,0,0,0.5);
    pointer-events: auto;
    touch-action: none;
}
#mobile-left-pad { left: 14px; }
#mobile-right-pad { right: 14px; }
#mobile-left-stick {
    will-change: transform;
    position: absolute;
    left: 50%;
    top: 50%;
    width: 42%;
    height: 42%;
    border-radius: 50%;
    border: 1px solid rgba(220,220,220,0.25);
    background: rgba(220,220,220,0.08);
    transform: translate(-50%, -50%);
    pointer-events: none;
}
#mobile-right-pad::after {
    content: 'LOOK';
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.42);
    font-size: 11px;
    letter-spacing: 2px;
}
#mobile-buttons {
    position: absolute;
    right: 20px;
    bottom: calc(min(38vw, 168px) + 38px);
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-end;
    gap: 10px;
    max-width: 320px;
    pointer-events: auto;
}
.mobile-btn {
    min-width: 90px;
    padding: 9px 12px;
    border: 1px solid rgba(190, 190, 190, 0.3);
    background: rgba(0, 0, 0, 0.5);
    color: rgba(245, 245, 245, 0.9);
    letter-spacing: 1px;
    font-size: 11px;
    touch-action: none;
}
.mobile-btn:active,
.mobile-btn.pressed {
    border-color: rgba(220, 80, 80, 0.7);
    color: #fff;
    background: rgba(90, 0, 0, 0.55);
}
body.mobile-mode {
    cursor: default;
}
body.mobile-mode #dialogue {
    bottom: 158px;
    font-size: 16px;
    width: min(92vw, 640px);
}
body.mobile-mode #interact-prompt {
    transform: translate(-50%, 42px);
    font-size: 12px;
}
body.mobile-mode #battery-hud {
    right: 12px;
    bottom: 124px;
}
@media (max-width: 560px) {
    #mobile-left-pad,
    #mobile-right-pad {
        width: min(42vw, 158px);
        height: min(42vw, 158px);
    }
    #mobile-buttons {
        right: 14px;
        gap: 8px;
    }
    .mobile-btn {
        min-width: 78px;
        font-size: 10px;
        padding: 8px 10px;
    }
}

#ending {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    background: #000; z-index: 200; cursor: default;
}
#ending h1 { color: #8a0000; font-size: 36px; letter-spacing: 6px; }
#ending p { color: #444; font-size: 14px; margin-top: 20px; }
#ending .menu-btn {
    margin-top: 28px;
    color: #b0b0b0;
    background: transparent;
    border: 1px solid #363636;
    padding: 10px 20px;
    letter-spacing: 2px;
    cursor: pointer;
}
#ending .menu-btn:hover {
    color: #fff;
    border-color: #8a0000;
}

#pause-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.94);
    z-index: 190;
    cursor: default;
}
#pause-overlay h1 {
    font-family: 'Cinzel Decorative', cursive;
    color: #b69484;
    font-size: clamp(24px, 4.6vw, 48px);
    letter-spacing: 8px;
    text-transform: uppercase;
    margin-bottom: 8px;
    text-shadow: 0 0 24px rgba(120,0,0,0.42);
}
#pause-overlay .title-rule {
    width: 220px; height: 1px;
    background: linear-gradient(to right, transparent, #6a0000, transparent);
    margin-bottom: 12px;
}
#pause-overlay > p:not(.warning) {
    font-family: 'IM Fell English', serif;
    font-style: italic;
    color: #6c5c52;
    font-size: 13px;
    letter-spacing: 2px;
    margin-bottom: 28px;
}
#pause-overlay .menu-row {
    display: flex;
    gap: 12px;
    align-items: center;
}
#pause-overlay .menu-btn {
    position: relative;
    font-family: 'Share Tech Mono', monospace;
    color: #555;
    font-size: 10px;
    padding: 10px 24px;
    border: 1px solid #1e1e1e;
    background: transparent;
    cursor: pointer;
    letter-spacing: 3px;
    text-transform: uppercase;
    overflow: hidden;
    transition: color 0.35s, border-color 0.35s;
}
#pause-overlay .menu-btn::before {
    content: '';
    position: absolute; top: 0; left: 0; width: 2px; height: 100%;
    background: #7a0000;
    transform: scaleY(0); transform-origin: bottom;
    transition: transform 0.3s ease;
}
#pause-overlay .menu-btn::after {
    content: '';
    position: absolute; bottom: 0; left: 0; right: 0; height: 1px;
    background: linear-gradient(to right, transparent, #6a0000, transparent);
    transform: scaleX(0);
    transition: transform 0.4s ease 0.05s;
}
#pause-overlay .menu-btn:hover { color: #ccc; border-color: #444; }
#pause-overlay .menu-btn:hover::before { transform: scaleY(1); }
#pause-overlay .menu-btn:hover::after  { transform: scaleX(1); }
#pause-overlay .warning {
    margin-top: 18px;
    color: #3f3434;
    font-size: 10px;
    letter-spacing: 2px;
}

#inventory-bar {
    position: fixed;
    bottom: 22px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 6px;
    z-index: 55;
    pointer-events: none;
}
#inventory-bar.visible { display: flex; pointer-events: auto; }
.inv-slot {
    width: 56px; height: 56px;
    border: 1px solid rgba(180,190,220,0.25);
    background: rgba(0,0,0,0.55);
    border-radius: 4px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
    position: relative;
}
.inv-slot:hover {
    border-color: rgba(200,210,240,0.6);
    background: rgba(20,20,40,0.7);
}
.inv-slot.selected {
    border-color: rgba(140,180,255,0.8);
    box-shadow: 0 0 10px rgba(100,140,255,0.3), inset 0 0 8px rgba(100,140,255,0.15);
}
.inv-slot .slot-icon {
    font-size: 22px;
    filter: drop-shadow(0 0 2px rgba(180,200,255,0.4));
}
.inv-slot .slot-label {
    position: absolute;
    bottom: -16px;
    font-size: 8px;
    letter-spacing: 1px;
    color: rgba(180,190,220,0.6);
    text-transform: uppercase;
    white-space: nowrap;
}
.inv-slot.empty { opacity: 0.3; cursor: default; }

#gameboy-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    display: none;
    align-items: center; justify-content: center;
    z-index: 90;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(4px);
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
}
#gameboy-overlay.active { display: flex; }
#gameboy-shell {
    width: 280px;
    background: linear-gradient(145deg, #3a3a5c, #2a2a42);
    border-radius: 16px;
    padding: 20px 18px 30px;
    box-shadow: 0 0 40px rgba(60,60,120,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
    border: 1px solid rgba(100,100,160,0.2);
}
#gameboy-header {
    text-align: center;
    font-size: 10px;
    letter-spacing: 3px;
    color: rgba(160,170,200,0.5);
    margin-bottom: 10px;
    text-transform: uppercase;
}
#gameboy-screen-frame {
    background: #1a1a2e;
    border-radius: 6px;
    padding: 8px;
    border: 2px solid rgba(60,60,100,0.4);
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
}
#snake-canvas {
    display: block;
    width: 100%;
    image-rendering: pixelated;
    border-radius: 2px;
}
#gameboy-controls {
    margin-top: 16px;
    text-align: center;
    color: rgba(140,150,180,0.5);
    font-size: 9px;
    letter-spacing: 1px;
}
#gameboy-score {
    text-align: center;
    margin-top: 8px;
    font-size: 11px;
    color: rgba(140,200,140,0.8);
    letter-spacing: 2px;
}
#gameboy-close-hint {
    text-align: center;
    margin-top: 12px;
    font-size: 9px;
    color: rgba(180,180,200,0.35);
    letter-spacing: 1px;
}
#gameboy-snake-dpad {
    display: none;
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 140px;
    height: 140px;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr;
    grid-template-areas: ". up ." "left . right" ". down .";
    gap: 4px;
}
#gameboy-snake-dpad .dpad-btn {
    min-width: 40px;
    min-height: 40px;
    background: rgba(60,60,80,0.7);
    border: 1px solid rgba(120,120,150,0.4);
    border-radius: 8px;
    color: rgba(200,210,230,0.6);
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}
#gameboy-snake-dpad .dpad-btn:active { background: rgba(80,90,120,0.9); color: #fff; }
#gameboy-snake-dpad .dpad-up { grid-area: up; }
#gameboy-snake-dpad .dpad-down { grid-area: down; }
#gameboy-snake-dpad .dpad-left { grid-area: left; }
#gameboy-snake-dpad .dpad-right { grid-area: right; }
body.mobile-mode #gameboy-overlay.active #gameboy-snake-dpad { display: grid; }
#gameboy-snake-restart {
    display: none;
    position: absolute;
    bottom: 20px;
    right: 20px;
    padding: 10px 16px;
    background: rgba(80,120,80,0.8);
    border: 1px solid rgba(120,180,120,0.5);
    border-radius: 8px;
    color: #b8e0b8;
    font-size: 11px;
    letter-spacing: 1px;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
}
body.mobile-mode #gameboy-overlay.active #gameboy-snake-restart { display: block; }
#gameboy-close-btn {
    display: none;
    position: absolute;
    top: 16px;
    right: 16px;
    padding: 8px 14px;
    background: rgba(80,60,60,0.8);
    border: 1px solid rgba(140,100,100,0.5);
    border-radius: 6px;
    color: #c8a0a0;
    font-size: 10px;
    letter-spacing: 1px;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
}
body.mobile-mode #gameboy-overlay.active #gameboy-close-btn { display: block; }

#interact-prompt {
    position: fixed;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(220, 230, 255, 0.85);
    font-size: 13px;
    letter-spacing: 2px;
    z-index: 50;
    display: none;
    text-shadow: 0 0 10px rgba(100,130,200,0.4);
    background: rgba(0,0,0,0.35);
    padding: 6px 14px;
    border-radius: 4px;
    border: 1px solid rgba(150,170,220,0.15);
    backdrop-filter: blur(2px);
}

#dialogue {
    position: fixed;
    top: 70%;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(220, 230, 255, 0.9);
    font-size: 15px;
    letter-spacing: 1px;
    z-index: 50;
    display: none;
    text-align: center;
    max-width: 500px;
    text-shadow: 0 0 12px rgba(80,100,180,0.3);
    background: rgba(0,0,0,0.4);
    padding: 10px 20px;
    border-radius: 6px;
    border: 1px solid rgba(120,140,200,0.1);
}

#thought {
    position: fixed;
    top: 62%;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(160, 170, 200, 0.55);
    font-size: 12px;
    font-style: italic;
    letter-spacing: 1px;
    z-index: 50;
    display: none;
    text-shadow: 0 0 8px rgba(60,80,140,0.2);
}

#crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 3px; height: 3px;
    background: rgba(200, 210, 240, 0.5);
    border-radius: 50%;
    z-index: 40;
    box-shadow: 0 0 6px rgba(150,170,220,0.3);
    pointer-events: none;
}

#horror-grain {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
    z-index: 35;
    opacity: 0;
    mix-blend-mode: overlay;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
    transition: opacity 0.5s;
}
#horror-grain.active { opacity: 0.06; }

#sanity-indicator {
    position: fixed;
    top: 18px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 45;
    display: none;
    color: rgba(200,200,220,0.6);
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
}
</style>
</head>
<body>
<div id="overlay">
    <canvas id="menu-canvas"></canvas>
    <h1>The Bedroom</h1>
    <div class="title-rule"></div>
    <p>A psychological horror experience</p>
    <button class="start-btn" onclick="startGame()">
        <span class="c tl"></span><span class="c tr"></span>
        <span class="c bl"></span><span class="c br"></span>
        <span>ENTER</span>
    </button>
    <div class="menu-row">
        <button class="menu-btn" onclick="toggleSettingsMenu()">SETTINGS</button>
        <button class="menu-btn" onclick="toggleEndingsMenu()">ENDINGS</button>
        <button id="nightmare-btn" class="menu-btn nightmare-btn" style="display:none;" onclick="startGame('nightmare')">NIGHTMARE MODE</button>
    </div>
    <div id="endings-menu" style="display:none;">
        <h3>ENDINGS ARCHIVE</h3>
        <div id="endings-list"></div>
        <div id="nightmare-guide" style="margin-top: 20px; border-top: 1px solid #181818; padding-top: 15px;">
            <h4 style="font-size: 9px; color: #444; letter-spacing: 2px; margin-bottom: 8px;">NIGHTMARE SURVIVAL GUIDE</h4>
            <ul style="font-size: 8px; color: #666; padding-left: 15px; line-height: 1.6;">
                <li>Keep the lantern ON. Darkness drains your MIND.</li>
                <li>Lighter fluid is life. Find it on the desk, bed, or floor.</li>
                <li>Listen for the whispers. They tell you where the dark is strongest.</li>
                <li>If your MIND breaks (0%), the nightmare ends you.</li>
                <li>Survive until the morning light breaks through the window.</li>
            </ul>
        </div>
        <button class="menu-btn" style="margin-top:15px; width:100%;" onclick="toggleEndingsMenu()">CLOSE</button>
    </div>
    <div id="settings-menu">
        <h3>SETTINGS</h3>
        <div class="setting-row">
            <span>Subtitles</span>
            <input id="setting-subtitles" type="checkbox" checked>
        </div>
        <div class="setting-row">
            <span>Voice</span>
            <input id="setting-voice" type="checkbox" checked>
        </div>
        <div class="setting-row">
            <span>Always Skip Loading</span>
            <input id="setting-skip-loading" type="checkbox">
        </div>
        <div class="setting-row">
            <span>Photosensitive Safe Mode</span>
            <input id="setting-photosensitive" type="checkbox">
        </div>
        <div class="setting-row">
            <span>Reduce Flashing FX</span>
            <input id="setting-reduced-flashing" type="checkbox">
        </div>
        <div class="setting-row" style="align-items: center;">
            <span>Master Volume</span>
            <span id="setting-volume-label">80%</span>
        </div>
        <input id="setting-volume" type="range" min="0" max="1" step="0.01" value="0.8">
        <div class="setting-row" style="align-items: center; margin-top: 14px;">
            <span>FOV</span>
            <span id="setting-fov-label">70</span>
        </div>
        <input id="setting-fov" type="range" min="50" max="110" step="1" value="70">
        <div class="setting-row" style="align-items: center; margin-top: 14px;">
            <span>Sensitivity</span>
            <span id="setting-sens-label">100%</span>
        </div>
        <input id="setting-sens" type="range" min="0.0005" max="0.008" step="0.0001" value="0.002">
        <div class="setting-row" style="align-items: center; margin-top: 14px;">
            <span>Quality</span>
            <span id="setting-quality-label">HIGH</span>
        </div>
        <div id="quality-buttons" style="display:flex;gap:6px;margin-top:6px;">
            <button class="quality-btn" data-q="low">LOW</button>
            <button class="quality-btn" data-q="medium">MED</button>
            <button class="quality-btn selected" data-q="high">HIGH</button>
            <button class="quality-btn" data-q="extreme">EXTREME</button>
        </div>
    </div>
    <p class="warning">Best experienced with headphones in a dark room</p>
    <p id="progress-text"></p>
    <div id="loading-panel">
        <div id="loading-stage">Preparing room...</div>
        <div id="loading-bar-track"><div id="loading-bar-fill"></div></div>
        <div id="loading-percent">0%</div>
        <button id="loading-skip-btn" class="menu-btn" type="button">SKIP</button>
    </div>
</div>
<div id="pause-overlay">
    <h1>Paused</h1>
    <div class="title-rule"></div>
    <p>Take a breath. You're safe... for now.</p>
    <div class="menu-row">
        <button class="menu-btn" onclick="togglePauseMenu(false)">RESUME</button>
        <button class="menu-btn" onclick="goToMenu()">MAIN MENU</button>
    </div>
    <p class="warning">Press ESC to resume</p>
</div>
<div id="dialogue"></div>
<div id="thought"></div>
<div id="crosshair"></div>
<div id="interact-prompt">[ E ]</div>
<div id="vignette"></div>
<div id="static-overlay"></div>
<div id="blood-overlay"></div>
<div id="red-flash-overlay"></div>
<div id="flash"></div>
<div id="sleep-fade"></div>
<div id="battery-hud">FLUID 100%</div>
<div id="horror-grain"></div>
<div id="sanity-indicator"></div>
<div id="inventory-bar"></div>
<div id="gameboy-overlay">
    <div id="gameboy-shell">
        <div id="gameboy-header">GAME BOY</div>
        <div id="gameboy-screen-frame">
            <canvas id="snake-canvas" width="200" height="200"></canvas>
        </div>
        <div id="gameboy-score">SCORE: 0</div>
        <div id="gameboy-controls">WASD / ARROWS to move</div>
        <div id="gameboy-close-hint">[ ESC ] or [ TAB ] to close</div>
    </div>
    <div id="gameboy-snake-dpad" aria-hidden="true">
        <button type="button" class="dpad-btn dpad-up" data-dir="up">▲</button>
        <button type="button" class="dpad-btn dpad-down" data-dir="down">▼</button>
        <button type="button" class="dpad-btn dpad-left" data-dir="left">◀</button>
        <button type="button" class="dpad-btn dpad-right" data-dir="right">▶</button>
    </div>
    <button type="button" id="gameboy-snake-restart" aria-label="Restart Snake">RESTART</button>
    <button type="button" id="gameboy-close-btn" aria-label="Close Game Boy">CLOSE</button>
</div>
<div id="mobile-controls" aria-hidden="true">
    <div id="mobile-left-pad">
        <div id="mobile-left-stick"></div>
    </div>
    <div id="mobile-right-pad"></div>
    <div id="mobile-buttons">
        <button id="mobile-interact-btn" class="mobile-btn" type="button">INTERACT</button>
        <button id="mobile-flashlight-btn" class="mobile-btn" type="button">LIGHT</button>
        <button id="mobile-pause-btn" class="mobile-btn" type="button">PAUSE</button>
    </div>
</div>
<div id="ending">
    <h1>YOU WERE NEVER ALONE</h1>
    <p>Thank you for playing</p>
    <button class="menu-btn" onclick="goToMenu()">GO BACK TO MENU</button>
</div>
<video id="jumpscare-video" src="jumpscare.mp4" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:9999; object-fit:cover; pointer-events:none;" preload="auto"></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Reflector.js"></script>
<script>
// ── Menu particle / ambient effect ──────────────────────────────────────────
(function() {
    const canvas = document.getElementById('menu-canvas');
    const ctx = canvas.getContext('2d');
    let W, H, particles = [], animId;

    function resize() {
        W = canvas.width  = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // create floating dust motes
    for (let i = 0; i < 55; i++) {
        particles.push({
            x: Math.random() * 1,
            y: Math.random(),
            size: 0.4 + Math.random() * 1.2,
            speed: 0.00015 + Math.random() * 0.0003,
            drift: (Math.random() - 0.5) * 0.0002,
            alpha: 0.05 + Math.random() * 0.25,
            pulse: Math.random() * Math.PI * 2
        });
    }

    function draw(t) {
        ctx.clearRect(0, 0, W, H);
        for (const p of particles) {
            p.y -= p.speed;
            p.x += p.drift;
            p.pulse += 0.012;
            if (p.y < -0.02) { p.y = 1.02; p.x = Math.random(); }
            if (p.x < -0.02 || p.x > 1.02) p.drift *= -1;

            const px = p.x * W, py = p.y * H;
            const a  = p.alpha * (0.6 + 0.4 * Math.sin(p.pulse));
            // make some motes reddish, others grey
            const isRed = p.size > 1.2;
            ctx.beginPath();
            ctx.arc(px, py, p.size, 0, Math.PI * 2);
            ctx.fillStyle = isRed
                ? `rgba(140,20,20,${a})`
                : `rgba(160,140,130,${a * 0.5})`;
            ctx.fill();
        }
        animId = requestAnimationFrame(draw);
    }
    draw(0);

    // stop particles once the game starts (overlay hidden)
    const observer = new MutationObserver(() => {
        if (document.getElementById('overlay').style.opacity === '0') {
            cancelAnimationFrame(animId);
        }
    });
    observer.observe(document.getElementById('overlay'), { attributes: true, attributeFilter: ['style'] });
})();
// ────────────────────────────────────────────────────────────────────────────

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const SAVE_KEY = 'the_bedroom_save_v2';
const REQUIRED_ENDINGS_FOR_CLOSET = ['neverAlone', 'sleptThrough', 'phoneLine'];
const REQUIRED_ENDINGS_FOR_NIGHTMARE = ['neverAlone', 'sleptThrough', 'phoneLine', 'closet'];
const MOBILE_DETECTION_REGEX = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile/i;
const hasCoarsePointer = window.matchMedia ? window.matchMedia('(pointer: coarse)').matches : false;
const hasTouchInput = (navigator.maxTouchPoints || 0) > 0 || 'ontouchstart' in window;
const isMobileDevice = hasTouchInput && (hasCoarsePointer || MOBILE_DETECTION_REGEX.test(navigator.userAgent || ''));

const defaultSaveData = {
    endings: {
        neverAlone: false,
        sleptThrough: false,
        phoneLine: false,
        closet: false,
        nightmare: false,
        wallsClosing: false
    },
    settings: {
        subtitles: true,
        voice: true,
        autoSkipLoading: false,
        photosensitiveSafeMode: false,
        reducedFlashing: false,
        masterVolume: 0.8,
        fov: 70,
        sensitivity: 0.002,
        quality: 'high'
    }
};

function cloneDefaultSaveData() {
    return JSON.parse(JSON.stringify(defaultSaveData));
}

function loadSaveData() {
    try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return cloneDefaultSaveData();
        const parsed = JSON.parse(raw);
        return {
            endings: { ...defaultSaveData.endings, ...(parsed.endings || {}) },
            settings: { ...defaultSaveData.settings, ...(parsed.settings || {}) }
        };
    } catch (err) {
        return cloneDefaultSaveData();
    }
}

let saveData = loadSaveData();
let endingProgress = { ...saveData.endings };
let gameSettings = { ...saveData.settings };

const masterGain = audioCtx.createGain();
masterGain.gain.value = Math.max(0, Math.min(1, gameSettings.masterVolume));
masterGain.connect(audioCtx.destination);

function persistSaveData() {
    saveData = {
        endings: { ...endingProgress },
        settings: { ...gameSettings }
    };
    try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    } catch (err) {
        // Ignore storage failures so gameplay never breaks.
    }
}

function isClosetEndingUnlocked() {
    return REQUIRED_ENDINGS_FOR_CLOSET.every(key => endingProgress[key]);
}

function isNightmareModeUnlocked() {
    return REQUIRED_ENDINGS_FOR_NIGHTMARE.every(key => endingProgress[key]);
}

function updateNightmareMenuOption() {
    const btn = document.getElementById('nightmare-btn');
    if (!btn) return;
    const unlocked = isNightmareModeUnlocked();
    btn.style.display = unlocked ? 'inline-block' : 'none';
    btn.textContent = endingProgress.nightmare ? 'NIGHTMARE MODE (CLEARED)' : 'NIGHTMARE MODE';
}

function unlockedEndingCount() {
    return REQUIRED_ENDINGS_FOR_CLOSET.filter(key => endingProgress[key]).length;
}

function updateMenuProgressText() {
    const el = document.getElementById('progress-text');
    if (!el) return;
    if (isNightmareModeUnlocked()) {
        el.textContent = endingProgress.nightmare
            ? 'Nightmare ending completed.'
            : 'Nightmare Mode unlocked.';
    } else if (isClosetEndingUnlocked()) {
        el.textContent = 'Closet ending unlocked.';
    } else {
        el.textContent = `Closet unlock progress: ${unlockedEndingCount()}/${REQUIRED_ENDINGS_FOR_CLOSET.length}`;
    }
    updateNightmareMenuOption();
    renderEndingsList();
}

const ENDING_DETAILS = {
    sleptThrough: { title: "SLEPT THROUGH IT ALL", desc: "You ignored the signs and woke up to a new day.", hint: "Maybe try sleeping (Hold E on bed)?" },
    neverAlone: { title: "YOU WERE NEVER ALONE", desc: "The window was never just glass.", hint: "Check the window when things get dark." },
    phoneLine: { title: "THE LINE WAS NEVER DEAD", desc: "Someone was always on the other end.", hint: "Answer the phone on the desk when it buzzes." },
    closet: { title: "I'M BEHIND YOU", desc: "The closet held more than clothes.", hint: "Keep checking the closet (1% chance or unlock hiding)." },
    nightmare: { title: "SURVIVED THE NIGHTMARE", desc: "You stared into the abyss and didn't blink.", hint: "Complete Nightmare Mode by surviving the darkness." },
    wallsClosing: { title: "THE WALLS ARE CLOSING IN", desc: "The room swallowed you whole.", hint: "Listen to the whispers in Nightmare Mode..." }
};

function toggleEndingsMenu() {
    const menu = document.getElementById('endings-menu');
    const settings = document.getElementById('settings-menu');
    if (!menu) return;
    if (settings) settings.style.display = 'none';
    const isVisible = menu.style.display === 'block';
    menu.style.display = isVisible ? 'none' : 'block';
    if (!isVisible) renderEndingsList();
}

function renderEndingsList() {
    const container = document.getElementById('endings-list');
    if (!container) return;
    container.innerHTML = '';
    Object.keys(ENDING_DETAILS).forEach(key => {
        const data = ENDING_DETAILS[key];
        const unlocked = !!endingProgress[key];
        const div = document.createElement('div');
        div.className = `ending-entry ${unlocked ? 'unlocked' : 'locked'}`;
        div.innerHTML = `
            <div class="ending-title">${unlocked ? data.title : '???'}</div>
            <div class="ending-desc">${unlocked ? data.desc : 'This ending has not been discovered yet.'}</div>
            ${!unlocked ? `<div class="ending-hint">Hint: ${data.hint}</div>` : ''}
        `;
        container.appendChild(div);
    });
}

function markEndingComplete(key) {
    if (!key || endingProgress[key]) return;
    endingProgress[key] = true;
    persistSaveData();
    updateMenuProgressText();
}

function applySettingsToUI() {
    const subtitles = document.getElementById('setting-subtitles');
    const voice = document.getElementById('setting-voice');
    const skipLoading = document.getElementById('setting-skip-loading');
    const photosensitive = document.getElementById('setting-photosensitive');
    const reducedFlashing = document.getElementById('setting-reduced-flashing');
    const volume = document.getElementById('setting-volume');
    const volumeLabel = document.getElementById('setting-volume-label');
    if (subtitles) subtitles.checked = !!gameSettings.subtitles;
    if (voice) voice.checked = !!gameSettings.voice;
    if (skipLoading) skipLoading.checked = !!gameSettings.autoSkipLoading;
    if (photosensitive) photosensitive.checked = !!gameSettings.photosensitiveSafeMode;
    if (reducedFlashing) reducedFlashing.checked = !!gameSettings.reducedFlashing;
    if (volume) volume.value = `${gameSettings.masterVolume}`;
    if (volumeLabel) volumeLabel.textContent = `${Math.round(gameSettings.masterVolume * 100)}%`;

    const dialogueEl = document.getElementById('dialogue');
    const thoughtEl = document.getElementById('thought');
    if (dialogueEl) dialogueEl.style.display = gameSettings.subtitles ? 'block' : 'none';
    if (thoughtEl) thoughtEl.style.display = gameSettings.subtitles ? 'block' : 'none';

    const fovLabel = document.getElementById('setting-fov-label');
    const fovSlider = document.getElementById('setting-fov');
    if (fovLabel) fovLabel.textContent = `${gameSettings.fov}`;
    if (fovSlider) fovSlider.value = `${gameSettings.fov}`;

    const sensLabel = document.getElementById('setting-sens-label');
    const sensSlider = document.getElementById('setting-sens');
    if (sensLabel) sensLabel.textContent = `${Math.round((gameSettings.sensitivity / 0.002) * 100)}%`;
    if (sensSlider) sensSlider.value = `${gameSettings.sensitivity}`;

    const qualityLabel = document.getElementById('setting-quality-label');
    if (qualityLabel) qualityLabel.textContent = (gameSettings.quality || 'high').toUpperCase();
    document.querySelectorAll('.quality-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.q === (gameSettings.quality || 'high'));
    });
}

const QUALITY_PRESETS = {
    low: {
        pixelRatio: 0.75,
        shadowMap: false,
        shadowRes: 256,
        antialias: false,
        reflectorRes: 128,
        fogDensity: 12,
        toneExposure: 0.72,
        flashlightShadow: false,
        grainEnabled: false
    },
    medium: {
        pixelRatio: 1,
        shadowMap: true,
        shadowRes: 512,
        antialias: false,
        reflectorRes: 256,
        fogDensity: 15,
        toneExposure: 0.72,
        flashlightShadow: false,
        grainEnabled: true
    },
    high: {
        pixelRatio: Math.min(window.devicePixelRatio || 1, 2),
        shadowMap: true,
        shadowRes: 1024,
        antialias: true,
        reflectorRes: 512,
        fogDensity: 18,
        toneExposure: 0.72,
        flashlightShadow: true,
        grainEnabled: true
    },
    extreme: {
        pixelRatio: Math.min(window.devicePixelRatio || 1, 3),
        shadowMap: true,
        shadowRes: 2048,
        antialias: true,
        reflectorRes: 1024,
        fogDensity: 22,
        toneExposure: 0.72,
        flashlightShadow: true,
        grainEnabled: true
    }
};

function applyQualityPreset(preset) {
    const q = QUALITY_PRESETS[preset] || QUALITY_PRESETS.high;
    if (renderer) {
        renderer.setPixelRatio(q.pixelRatio);
        renderer.shadowMap.enabled = q.shadowMap;
        if (q.shadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    if (ceilingLight) {
        ceilingLight.shadow.mapSize.set(q.shadowRes, q.shadowRes);
    }
    if (flashlightLight) {
        flashlightLight.castShadow = q.flashlightShadow;
        if (q.flashlightShadow) {
            flashlightLight.shadow.mapSize.set(q.shadowRes, q.shadowRes);
            flashlightLight.shadow.bias = -0.002;
            flashlightLight.shadow.radius = 2;
        }
    }
    const grain = document.getElementById('horror-grain');
    if (grain && !q.grainEnabled) grain.style.display = 'none';
    else if (grain) grain.style.display = '';
}

function isPhotosensitiveSafeModeEnabled() {
    return !!gameSettings.photosensitiveSafeMode;
}

function shouldReduceFlashingEffects() {
    return !!gameSettings.reducedFlashing || isPhotosensitiveSafeModeEnabled();
}

function safeFlashOpacity(baseOpacity = 1) {
    if (!shouldReduceFlashingEffects()) return baseOpacity;
    return Math.min(0.22, Math.max(0.08, baseOpacity * 0.22));
}

function triggerScreenFlash(baseOpacity = 1, holdMs = 100, fadeOutMs = 300) {
    const flash = document.getElementById('flash');
    if (!flash) return;
    const reduced = shouldReduceFlashingEffects();
    const inMs = reduced ? 180 : 50;
    const hold = reduced ? Math.max(260, holdMs * 2) : holdMs;
    const fade = reduced ? Math.max(480, fadeOutMs + 180) : fadeOutMs;

    flash.style.transition = `opacity ${inMs}ms ease`;
    flash.style.opacity = `${safeFlashOpacity(baseOpacity)}`;
    setTimeout(() => {
        flash.style.transition = `opacity ${fade}ms ease`;
        flash.style.opacity = '0';
    }, hold);
}

function applySettings() {
    masterGain.gain.value = Math.max(0, Math.min(1, gameSettings.masterVolume));
    if (!gameSettings.voice && 'speechSynthesis' in window) {
        window.speechSynthesis.cancel();
    }
    if (camera) {
        camera.fov = gameSettings.fov;
        camera.updateProjectionMatrix();
    }
    document.body.classList.toggle('photosensitive-safe', shouldReduceFlashingEffects());
    if (shouldReduceFlashingEffects()) {
        const staticOverlay = DOM.staticOverlay || document.getElementById('static-overlay');
        const bloodOverlay = DOM.bloodOverlay || document.getElementById('blood-overlay');
        const redFlashOverlay = document.getElementById('red-flash-overlay');
        if (staticOverlay) staticOverlay.style.opacity = '0';
        if (bloodOverlay) bloodOverlay.style.opacity = '0';
        if (redFlashOverlay) redFlashOverlay.style.opacity = '0';
    }
    applyQualityPreset(gameSettings.quality || 'high');
    persistSaveData();
    applySettingsToUI();
}

function toggleSettingsMenu() {
    const menu = document.getElementById('settings-menu');
    if (!menu) return;
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
}

function setPauseState(paused) {
    gamePaused = !!paused;
    const pauseOverlay = DOM.pauseOverlay || document.getElementById('pause-overlay');
    if (pauseOverlay) pauseOverlay.style.display = gamePaused ? 'flex' : 'none';
    const promptEl = DOM.interactPrompt || document.getElementById('interact-prompt');
    if (promptEl) promptEl.style.display = gamePaused ? 'none' : '';
    const crosshairEl = document.getElementById('crosshair');
    if (crosshairEl) crosshairEl.style.display = gamePaused ? 'none' : '';

    if (gamePaused) {
        interactKeyHeld = false;
        bedHoldSeconds = 0;
        closetHoldSeconds = 0;
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        sprintHeld = false;
        if (isMobileDevice) {
            resetMobileMoveState();
            mobileLookTouchId = null;
        }
        if (document.exitPointerLock && document.pointerLockElement) {
            document.exitPointerLock();
        }
        return;
    }

    if (!isMobileDevice && gameStarted && !endingTriggered && renderer && renderer.domElement && renderer.domElement.requestPointerLock) {
        try { renderer.domElement.requestPointerLock(); } catch (_) {}
    }
}

function togglePauseMenu(forceState) {
    if (!gameStarted || gameStartInProgress || endingTriggered) return;
    if (sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
    if (gameboyActive) closeGameBoy();
    const nextState = typeof forceState === 'boolean' ? forceState : !gamePaused;
    setPauseState(nextState);
}

function formatPromptForDevice(text) {
    if (!isMobileDevice) return text;
    return String(text || '')
        .replace(/\[\s*HOLD E\s*\]/gi, '[ HOLD ]')
        .replace(/\[\s*E\s*\]/gi, '[ TAP ]')
        .replace(/\[\s*F\s*\]/gi, '[ TAP LIGHT ]');
}

function showEndingScreen(title, subtitle, endingKey) {
    if (endingKey) markEndingComplete(endingKey);
    dialogueSourceLock = null;
    gamePaused = false;
    if (DOM.pauseOverlay) DOM.pauseOverlay.style.display = 'none';
    const ending = document.getElementById('ending');
    ending.querySelector('h1').textContent = title;
    ending.querySelector('p').textContent = subtitle;
    ending.style.display = 'flex';
    if (document.exitPointerLock && document.pointerLockElement) {
        document.exitPointerLock();
    }
    
    // Stop footsteps
    if (walkingAudio && !walkingAudio.paused) walkingAudio.pause();
    if (runningAudio && !runningAudio.paused) runningAudio.pause();

    setMobileControlsActive(false);
    updateBatteryHud();
}

function goToMenu() {
    location.reload();
}

function configureGameMode(mode = 'normal') {
    const wantsNightmare = mode === 'nightmare' && isNightmareModeUnlocked();
    currentGameMode = wantsNightmare ? 'nightmare' : 'normal';
    nightmareActive = currentGameMode === 'nightmare';
    phaseTimers = nightmareActive ? { ...NIGHTMARE_PHASE_TIMERS } : { ...NORMAL_PHASE_TIMERS };
    phaseExecuted = {};
    phase = 0;
    gameTime = 0;
    nextKnockTime = nightmareActive ? 4.2 : 12;
}

function clearNightmareBatteries() {
    nightmareBatteryMeshes.forEach(pack => {
        if (pack && pack.parent) pack.parent.remove(pack);
    });
    nightmareBatteryMeshes = [];
}

const BATTERY_SPAWN_LOCATIONS = [
    { x: -2.2, y: 0.78, z: 0.35 }, // Bed/Nightstand area
    { x: 2.15, y: 0.1, z: -2.75 }, // Near desk (floor)
    { x: 1.05, y: 0.1, z: 2.4 },   // Near door (floor)
    { x: -0.3, y: 0.1, z: -2.9 },  // Near window (floor)
    { x: 2.5, y: 0.78, z: -2.2 },  // On desk
    { x: -3.0, y: 0.1, z: 0.5 },   // Near closet (floor)
    { x: 0.0, y: 0.1, z: 0.0 },    // Center room (floor)
    { x: 3.2, y: 0.1, z: 2.8 },    // Corner near door
    { x: -3.2, y: 0.1, z: -2.8 },  // Corner near window
    { x: 1.5, y: 0.1, z: -1.0 },   // Random floor spot
    { x: -1.5, y: 0.1, z: 1.0 }    // Random floor spot
];

function spawnNightmareBatteries() {
    clearNightmareBatteries();
    if (!nightmareActive || !scene) return;

    // Spawn 3 initial batteries at random locations
    for (let i = 0; i < 3; i++) {
        spawnSingleBattery();
    }
}

function spawnSingleBattery() {
    if (nightmareBatteryMeshes.length >= 5) return; // Max 5 batteries at once

    // Pick a random location
    const p = BATTERY_SPAWN_LOCATIONS[Math.floor(Math.random() * BATTERY_SPAWN_LOCATIONS.length)];
    
    // Check if a battery is already near this location to avoid stacking
    const isTooClose = nightmareBatteryMeshes.some(b => b.visible && b.position.distanceTo(new THREE.Vector3(p.x, p.y, p.z)) < 0.5);
    if (isTooClose) return; // Skip this spawn attempt if too close

    const pack = new THREE.Group();
    pack.userData.isNightmareBattery = true;
    pack.userData.collected = false;
    pack.userData.charge = 0.35 + Math.random() * 0.15; // Random charge amount

    if (nightmareActive) {
        // --- LIGHTER (NIGHTMARE MODE) ---
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.08, 0.015),
            new THREE.MeshStandardMaterial({ color: 0xcc2222, metalness: 0.1, roughness: 0.8 })
        );
        pack.add(body);

        const metalTop = new THREE.Mesh(
            new THREE.BoxGeometry(0.038, 0.02, 0.013),
            new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.3 })
        );
        metalTop.position.y = 0.05;
        pack.add(metalTop);

        const sparkWheel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.005, 0.005, 0.01, 8),
            new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.6 })
        );
        sparkWheel.rotation.z = Math.PI / 2;
        sparkWheel.position.set(0.01, 0.06, 0);
        pack.add(sparkWheel);

        const glow = new THREE.PointLight(0xff6622, 0, 1.5, 1.6);
        glow.position.set(0, 0.03, 0);
        pack.add(glow);
        pack.userData.glow = glow;
    } else {
        // --- BATTERY (NORMAL MODE) ---
        const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.028, 0.028, 0.11, 10),
            new THREE.MeshStandardMaterial({ color: 0x56606b, metalness: 0.45, roughness: 0.38 })
        );
        body.rotation.z = Math.PI / 2;
        pack.add(body);

        const tip = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.012, 0.022, 8),
            new THREE.MeshStandardMaterial({ color: 0x7ca8d8, metalness: 0.8, roughness: 0.25, emissive: 0x1f3d5c, emissiveIntensity: 0.45 })
        );
        tip.rotation.z = Math.PI / 2;
        tip.position.x = 0.06;
        pack.add(tip);

        const glow = new THREE.PointLight(0x7cb7ff, 0, 1.5, 1.6);
        glow.position.set(0, 0.03, 0);
        pack.add(glow);
        pack.userData.glow = glow;
    }

    pack.position.set(p.x, p.y, p.z);
    pack.rotation.y = Math.random() * Math.PI * 2;
    pack.visible = false; // Will be made visible by setNightmareBatteryVisibility if conditions met
    scene.add(pack);
    nightmareBatteryMeshes.push(pack);
    
    // If we should be seeing batteries, make it visible immediately
    if (blackoutTriggered && flashlightHeld && !endingTriggered) {
        pack.visible = true;
        if (pack.userData.glow) pack.userData.glow.intensity = 0.32;
    }
}

function setNightmareBatteryVisibility(visible) {
    nightmareBatteryMeshes.forEach(pack => {
        if (!pack || pack.userData.collected) return;
        pack.visible = !!visible;
        if (pack.userData.glow) pack.userData.glow.intensity = visible ? 0.32 : 0;
    });
}

function resolveNightmareBatteryFromObject(obj) {
    let current = obj;
    while (current && !current.userData.isNightmareBattery) {
        current = current.parent;
    }
    if (!current || current.userData.collected || !current.visible) return null;
    return current;
}

function getLookedAtNightmareBattery(raycaster) {
    if (!nightmareActive || !blackoutTriggered || !nightmareBatteryMeshes.length) return null;
    const hits = raycaster.intersectObjects(nightmareBatteryMeshes, true);
    if (!hits.length) return null;
    for (const hit of hits) {
        const battery = resolveNightmareBatteryFromObject(hit.object);
        if (battery) return battery;
    }
    return null;
}

function updateBatteryHud() {
    const hud = DOM.batteryHud;
    if (!hud) return;
    const show = nightmareActive && gameStarted && blackoutTriggered && flashlightHeld && !endingTriggered;
    hud.style.display = show ? 'block' : 'none';
    if (!show) return;
    const pct = Math.round(Math.max(0, Math.min(1, flashlightBattery)) * 100);
    hud.textContent = nightmareActive ? `FLUID ${pct}%` : `BATTERY ${pct}%`;
    hud.classList.toggle('low', pct <= 20);
}

// --- INVENTORY SYSTEM ---
function addToInventory(itemId, label, icon) {
    if (inventory.find(i => i.id === itemId)) return;
    inventory.push({ id: itemId, label, icon });
    renderInventoryBar();
    showDialogue(`Picked up: ${label}`, 1500);
    playTone(880, 0.06, 'square', 0.02);
    setTimeout(() => playTone(1100, 0.08, 'square', 0.02), 80);
}

function removeFromInventory(itemId) {
    inventory = inventory.filter(i => i.id !== itemId);
    renderInventoryBar();
}

function hasItem(itemId) {
    return !!inventory.find(i => i.id === itemId);
}

function renderInventoryBar() {
    const bar = DOM.inventoryBar;
    if (!bar) return;
    bar.innerHTML = '';
    const maxSlots = 5;
    for (let i = 0; i < maxSlots; i++) {
        const slot = document.createElement('div');
        slot.className = 'inv-slot' + (i >= inventory.length ? ' empty' : '');
        if (i < inventory.length) {
            const item = inventory[i];
            const iconEl = document.createElement('span');
            iconEl.className = 'slot-icon';
            iconEl.textContent = item.icon;
            slot.appendChild(iconEl);
            const labelEl = document.createElement('span');
            labelEl.className = 'slot-label';
            labelEl.textContent = item.label;
            slot.appendChild(labelEl);
            slot.addEventListener('click', () => useInventoryItem(item.id));
        }
        bar.appendChild(slot);
    }
    bar.classList.toggle('visible', inventory.length > 0 && gameStarted && !endingTriggered);
}

function useInventoryItem(itemId) {
    if (itemId === 'gameboy') {
        openGameBoy();
    }
}

// --- GAME BOY / SNAKE ---
function openGameBoy() {
    if (gameboyActive) return;
    gameboyActive = true;
    if (document.exitPointerLock) document.exitPointerLock();
    const overlay = DOM.gameboyOverlay;
    if (overlay) overlay.classList.add('active');
    const controlsHint = document.getElementById('gameboy-controls');
    if (controlsHint) controlsHint.textContent = isMobileDevice ? 'Touch D-pad to move' : 'WASD / ARROWS to move';
    snakeCanvas = DOM.snakeCanvas;
    if (snakeCanvas) snakeCtx = snakeCanvas.getContext('2d');
    startSnakeGame();
}

function closeGameBoy() {
    if (!gameboyActive) return;
    gameboyActive = false;
    if (snakeInterval) { clearTimeout(snakeInterval); snakeInterval = null; }
    if (DOM.gameboyOverlay) DOM.gameboyOverlay.classList.remove('active');
    if (!isMobileDevice && document.body.requestPointerLock) {
        try { document.body.requestPointerLock(); } catch (_) {}
    }
}

let snakeNextDir = null;
let snakeHighScore = 0;

function startSnakeGame() {
    if (!snakeCanvas) return;
    const gridSize = 20;
    const cellSize = snakeCanvas.width / gridSize;
    snakeBody = [{x:10,y:10},{x:9,y:10},{x:8,y:10}];
    snakeDir = {x:1,y:0};
    snakeNextDir = null;
    snakeScore = 0;
    snakeAlive = true;
    placeSnakeFood(gridSize);
    updateSnakeScoreDisplay();

    if (snakeInterval) clearTimeout(snakeInterval);
    let snakeSpeed = 110;
    function snakeTick() {
        if (!snakeAlive || !gameboyActive) return;
        if (snakeNextDir) { snakeDir = snakeNextDir; snakeNextDir = null; }
        const head = { x: snakeBody[0].x + snakeDir.x, y: snakeBody[0].y + snakeDir.y };
        if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
            snakeDie(); return;
        }
        for (let i = 0; i < snakeBody.length; i++) {
            if (snakeBody[i].x === head.x && snakeBody[i].y === head.y) {
                snakeDie(); return;
            }
        }
        snakeBody.unshift(head);
        if (head.x === snakeFood.x && head.y === snakeFood.y) {
            snakeScore += 10;
            if (snakeScore > snakeHighScore) snakeHighScore = snakeScore;
            updateSnakeScoreDisplay();
            placeSnakeFood(gridSize);
            playTone(660, 0.04, 'square', 0.01);
            snakeSpeed = Math.max(55, 110 - snakeScore * 0.5);
        } else {
            snakeBody.pop();
        }
        drawSnake(gridSize, cellSize);
        snakeInterval = setTimeout(snakeTick, snakeSpeed);
    }
    snakeInterval = setTimeout(snakeTick, snakeSpeed);
    drawSnake(gridSize, cellSize);
}

function placeSnakeFood(gridSize) {
    let valid = false;
    while (!valid) {
        snakeFood = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
        valid = !snakeBody.some(s => s.x === snakeFood.x && s.y === snakeFood.y);
    }
}

function drawSnake(gridSize, cellSize) {
    if (!snakeCtx) return;
    const ctx = snakeCtx;
    const w = snakeCanvas.width;
    const cs = cellSize;

    ctx.fillStyle = '#0f380f';
    ctx.fillRect(0, 0, w, w);

    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            if ((x + y) % 2 === 0) {
                ctx.fillStyle = '#0e3a0e';
                ctx.fillRect(x * cs, y * cs, cs, cs);
            }
        }
    }

    snakeBody.forEach((seg, i) => {
        const t = i / Math.max(1, snakeBody.length - 1);
        const r = Math.round(0x9b - t * 0x30);
        const g = Math.round(0xbc - t * 0x20);
        ctx.fillStyle = `rgb(${r},${g},15)`;
        const shrink = i === 0 ? 0.5 : 1;
        const sx = seg.x * cs + shrink, sy = seg.y * cs + shrink, sw = cs - shrink * 2, sh = cs - shrink * 2;
        const rad = i === 0 ? 3 : 2;
        ctx.beginPath();
        if (ctx.roundRect) { ctx.roundRect(sx, sy, sw, sh, rad); }
        else { ctx.moveTo(sx + rad, sy); ctx.arcTo(sx + sw, sy, sx + sw, sy + sh, rad); ctx.arcTo(sx + sw, sy + sh, sx, sy + sh, rad); ctx.arcTo(sx, sy + sh, sx, sy, rad); ctx.arcTo(sx, sy, sx + sw, sy, rad); ctx.closePath(); }
        ctx.fill();
        if (i === 0) {
            ctx.fillStyle = '#0f380f';
            const ex = seg.x * cs + cs * 0.3;
            const ey = seg.y * cs + cs * 0.35;
            ctx.fillRect(ex, ey, 2, 2);
            ctx.fillRect(ex + cs * 0.35, ey, 2, 2);
        }
    });

    const foodPulse = 0.8 + Math.sin(Date.now() * 0.008) * 0.2;
    const fs = cs * 0.65 * foodPulse;
    const fx = snakeFood.x * cs + (cs - fs) / 2;
    const fy = snakeFood.y * cs + (cs - fs) / 2;
    ctx.fillStyle = '#306230';
    ctx.beginPath();
    ctx.arc(fx + fs / 2, fy + fs / 2, fs / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1a4a1a';
    ctx.beginPath();
    ctx.arc(fx + fs / 2, fy + fs / 2, fs / 3, 0, Math.PI * 2);
    ctx.fill();

    if (!snakeAlive) {
        ctx.fillStyle = 'rgba(15,56,15,0.75)';
        ctx.fillRect(0, 0, w, w);
        ctx.fillStyle = '#9bbc0f';
        ctx.font = 'bold 18px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', w / 2, w / 2 - 18);
        ctx.font = '11px monospace';
        ctx.fillText(`Score: ${snakeScore}`, w / 2, w / 2 + 2);
        if (snakeHighScore > 0) {
            ctx.fillStyle = '#6a8a0f';
            ctx.font = '9px monospace';
            ctx.fillText(`Best: ${snakeHighScore}`, w / 2, w / 2 + 16);
        }
        ctx.fillStyle = '#7a9a0f';
        ctx.font = '10px monospace';
        ctx.fillText('SPACE to restart', w / 2, w / 2 + 34);
    }
}

function snakeDie() {
    snakeAlive = false;
    playTone(200, 0.2, 'sawtooth', 0.03);
    if (snakeCanvas) drawSnake(20, snakeCanvas.width / 20);
    if (nightmareActive && Math.random() < 0.3) {
        setTimeout(() => {
            if (gameboyActive) {
                playScaryVoiceLine(NIGHTMARE_WHISPERS[Math.floor(Math.random() * NIGHTMARE_WHISPERS.length)]);
            }
        }, 500);
    }
}

function updateSnakeScoreDisplay() {
    const el = DOM.gameboyScore;
    if (el) el.textContent = snakeHighScore > 0 ? `SCORE: ${snakeScore}  |  BEST: ${snakeHighScore}` : `SCORE: ${snakeScore}`;
}

// --- HORROR GRAIN & SANITY ---
let horrorGrainActive = false;
let sanityLevel = 100;

function updateHorrorGrain() {
    const grain = DOM.horrorGrain;
    if (!grain) return;
    const shouldShow = gameStarted && !endingTriggered && phase >= 3;
    grain.classList.toggle('active', shouldShow);
    if (shouldShow && phase >= 6) {
        grain.style.opacity = Math.min(0.12, 0.04 + (phase - 5) * 0.015).toString();
    }
}

function updateSanityIndicator() {
    const el = DOM.sanityIndicator;
    if (!el) return;
    if (!nightmareActive || !gameStarted || endingTriggered || phase < 4) {
        el.style.display = 'none';
        return;
    }
    el.style.display = 'block';
    const inDarkness = blackoutTriggered && (!flashlightHeld || !flashlightOn || flashlightBattery <= 0.01);
    if (inDarkness) sanityLevel = Math.max(0, sanityLevel - 0.08); // Balanced: was 0.15
    else sanityLevel = Math.min(100, sanityLevel + 0.06); // Balanced: was 0.05
    const label = sanityLevel > 75 ? 'STABLE' : sanityLevel > 45 ? 'UNEASY' : sanityLevel > 20 ? 'FRACTURING' : 'BREAKING';
    const color = sanityLevel > 75 ? 'rgba(140,200,140,0.6)' : sanityLevel > 45 ? 'rgba(200,200,100,0.6)' : sanityLevel > 20 ? 'rgba(200,120,80,0.7)' : 'rgba(200,60,60,0.8)';
    el.textContent = `MIND: ${label}`;
    el.style.color = color;
    if (sanityLevel <= 20) {
        el.style.textShadow = `0 0 8px rgba(200,40,40,0.8)`;
        if (Math.random() < 0.05) el.style.opacity = (0.3 + Math.random() * 0.7).toString();
        else el.style.opacity = '1';
    } else {
        el.style.textShadow = 'none';
        el.style.opacity = '1';
    }
    if (sanityLevel <= 0) {
        triggerNightmareDeath("LOST YOUR MIND", "The darkness finally took root in your thoughts.");
    }
}

let scaryAmbientTimer = 0;
let furnitureShiftTimer = 0;
let breathingEffectTimer = 0;

function updateScaryAmbientEffects(dt) {
    if (!gameStarted || endingTriggered || sleepEndingActive || sleepTransitionActive) return;

    scaryAmbientTimer += dt;
    breathingEffectTimer += dt;

    if (phase >= 5) {
        const vignette = DOM.vignette;
        if (vignette) {
            const pulse = Math.sin(breathingEffectTimer * 1.2) * 0.15 + 0.85;
            vignette.style.background = `radial-gradient(ellipse at center, transparent ${45 * pulse}%, rgba(0,0,0,${0.7 + (phase - 5) * 0.05}) 100%)`;
        }
    }

    if (phase >= 4 && scaryAmbientTimer > 8 + Math.random() * 12) {
        scaryAmbientTimer = 0;
        const event = Math.random();
        const reducedFlashing = shouldReduceFlashingEffects();
        if (event < 0.15 && ceilingLight && houseLightsOn && !blackoutTriggered) {
            const origIntensity = ceilingLight.intensity;
            if (reducedFlashing) {
                ceilingLight.intensity = origIntensity * 0.75;
                setTimeout(() => { if (ceilingLight) ceilingLight.intensity = origIntensity; }, 320);
            } else {
                ceilingLight.intensity = 0;
                setTimeout(() => { if (ceilingLight) ceilingLight.intensity = origIntensity * 0.3; }, 80);
                setTimeout(() => { if (ceilingLight) ceilingLight.intensity = 0; }, 160);
                setTimeout(() => { if (ceilingLight) ceilingLight.intensity = origIntensity; }, 300);
            }
        } else if (event < 0.3) {
            const staticOverlay = DOM.staticOverlay;
            if (staticOverlay) {
                staticOverlay.style.opacity = reducedFlashing ? '0.02' : '0.08';
                setTimeout(() => { staticOverlay.style.opacity = '0'; }, reducedFlashing ? 420 : 200 + Math.random() * 300);
            }
        } else if (event < 0.45 && phase >= 6) {
            const bloodOverlay = DOM.bloodOverlay;
            if (bloodOverlay) {
                bloodOverlay.style.opacity = reducedFlashing ? '0.015' : '0.04';
                setTimeout(() => { bloodOverlay.style.opacity = '0'; }, 1500);
            }
        } else if (event < 0.6 && phase >= 5) {
            playTone(40 + Math.random() * 30, 0.08, 'sawtooth', 0.05);
        }
    }

    if (phase >= 6 && nightmareActive) {
        furnitureShiftTimer += dt;
        if (furnitureShiftTimer > 15 + Math.random() * 20) {
            furnitureShiftTimer = 0;
            furnitureObjects.forEach(obj => {
                if (Math.random() < 0.15 && obj.userData.basePos && obj.userData.canShift !== false) {
                    const offset = 0.02 + Math.random() * 0.03;
                    obj.position.x = obj.userData.basePos.x + (Math.random() - 0.5) * offset;
                    obj.position.z = obj.userData.basePos.z + (Math.random() - 0.5) * offset;
                }
            });
            if (Math.random() < 0.4) {
                playCreak();
            }
        }
    }
}

function collectNightmareBattery(batteryPack) {
    if (!batteryPack || batteryPack.userData.collected) return;
    batteryPack.userData.collected = true;
    batteryPack.visible = false;
    scene.remove(batteryPack);
    const idx = nightmareBatteryMeshes.indexOf(batteryPack);
    if (idx > -1) nightmareBatteryMeshes.splice(idx, 1);

    flashlightBattery = Math.min(1, flashlightBattery + (batteryPack.userData.charge || 0.35));
    flashlightBatteryNotifiedDead = flashlightBattery <= 0;
    playTone(980, 0.06, 'square', 0.03);
    playTone(640, 0.18, 'triangle', 0.02);
    showDialogue(nightmareActive ? "Lighter found. Lantern refueled." : "Battery found. The beam steadies.", 1900);
    updateBatteryHud();

    // Respawn a new battery after 12-24 seconds
    setTimeout(() => {
        if (nightmareActive && !endingTriggered && gameStarted) {
            spawnSingleBattery();
        }
    }, 12000 + Math.random() * 12000);
}

function resetNightmareRunState() {
    nightmareDeathPending = false;
    wallEndingActive = false;
    wallEndingTriggered = false;
    nightmareWhisperTimer = 2.6 + Math.random() * 3;
    nightmareKnockBurstTimer = 1.8 + Math.random() * 2.2;
    nightmareDarknessTimer = 0;
    flashlightBattery = 1;
    flashlightBatteryDrainDuration = Math.max(12, (phaseTimers[9] - phaseTimers[6]) * 0.5);
    flashlightBatteryNotifiedDead = false;
    if (nightmareActive) {
        spawnNightmareBatteries();
    } else {
        clearNightmareBatteries();
    }
    updateBatteryHud();
}

function waitForAnimationFrame() {
    return new Promise(resolve => requestAnimationFrame(resolve));
}

function delayMs(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function setLoadingPanelActive(active) {
    const overlay = DOM.overlay || document.getElementById('overlay');
    if (!overlay) return;
    overlay.classList.toggle('loading-active', !!active);
    if (!active) {
        loadingProgressValue = 0;
        if (DOM.loadingBarFill) DOM.loadingBarFill.style.width = '0%';
        if (DOM.loadingPercent) DOM.loadingPercent.textContent = '0%';
        if (DOM.loadingStage) DOM.loadingStage.textContent = 'Preparing room...';
        if (DOM.loadingSkipButton) DOM.loadingSkipButton.disabled = false;
    }
}

function updateLoadingPanel(progress, stageText = '') {
    const normalized = Math.max(0, Math.min(1, progress));
    loadingProgressValue = Math.max(loadingProgressValue, normalized);
    if (DOM.loadingBarFill) DOM.loadingBarFill.style.width = `${Math.round(loadingProgressValue * 100)}%`;
    if (DOM.loadingPercent) DOM.loadingPercent.textContent = `${Math.round(loadingProgressValue * 100)}%`;
    if (stageText && DOM.loadingStage) DOM.loadingStage.textContent = stageText;
}

function preloadAudioElement(audioEl, timeoutMs = 1400) {
    return new Promise(resolve => {
        if (!audioEl) { resolve(); return; }
        let finished = false;
        let timerId = null;
        const done = () => {
            if (finished) return;
            finished = true;
            clearTimeout(timerId);
            audioEl.removeEventListener('canplaythrough', done);
            audioEl.removeEventListener('loadeddata', done);
            audioEl.removeEventListener('error', done);
            resolve();
        };
        audioEl.addEventListener('canplaythrough', done);
        audioEl.addEventListener('loadeddata', done);
        audioEl.addEventListener('error', done);
        timerId = setTimeout(done, timeoutMs);
        try {
            audioEl.preload = 'auto';
            audioEl.load();
        } catch (err) {
            done();
            return;
        }
        if (audioEl.readyState >= 3) done();
    });
}

function beginGameplayAfterLoading(token) {
    if (token !== loadingRunToken) return;
    const overlay = DOM.overlay || document.getElementById('overlay');
    if (!overlay) {
        gameStartInProgress = false;
        return;
    }
    setLoadingPanelActive(false);
    overlay.style.opacity = '0';
    setTimeout(() => {
        if (token !== loadingRunToken) return;
        overlay.style.display = 'none';
        gameStarted = true;
        gameStartInProgress = false;
        setMobileControlsActive(isMobileDevice);
        if (!isMobileDevice && renderer.domElement.requestPointerLock) {
            renderer.domElement.requestPointerLock();
        }

        // Start ambient drone
        playDrone(nightmareActive ? 52 : 65, nightmareActive ? 10 : 8);
        ambientInterval = setInterval(() => {
            if (!endingTriggered) {
                if (nightmareActive) {
                    playDrone(32 + Math.random() * 18, 8 + Math.random() * 3);
                } else {
                    playDrone(55 + Math.random() * 20, 6 + Math.random() * 4);
                }
            }
        }, nightmareActive ? 5200 : 8000);

        showDialogue(
            nightmareActive
                ? "The room remembers you. Survive it."
                : "Just another night... everything is fine.",
            4200
        );
        if (nightmareActive) {
            showThought("Nightmare mode: survive, manage lantern fluid, do not stay in the dark.");
        }
    }, 650);
}

async function runStartupLoadingSequence(token) {
    if (token !== loadingRunToken) return;
    if (gameSettings.autoSkipLoading) {
        beginGameplayAfterLoading(token);
        return;
    }

    setLoadingPanelActive(true);
    loadingSkipRequested = false;
    updateLoadingPanel(0.05, 'Initializing...');
    await waitForAnimationFrame();
    if (token !== loadingRunToken) return;

    const shouldSkip = () => loadingSkipRequested || token !== loadingRunToken;

    if (!shouldSkip()) {
        updateLoadingPanel(0.22, 'Caching footsteps...');
        await preloadAudioElement(walkingAudio, 1400);
    }
    if (!shouldSkip()) {
        updateLoadingPanel(0.36, 'Caching sprint audio...');
        await preloadAudioElement(runningAudio, 1400);
    }
    if (!shouldSkip()) {
        updateLoadingPanel(0.58, 'Compiling shaders...');
        if (renderer && scene && camera && typeof renderer.compile === 'function') {
            renderer.compile(scene, camera);
        }
        await waitForAnimationFrame();
    }
    if (!shouldSkip()) {
        const warmupFrames = nightmareActive ? 9 : 7;
        for (let i = 0; i < warmupFrames; i++) {
            if (shouldSkip()) break;
            updateLoadingPanel(0.62 + ((i + 1) / warmupFrames) * 0.32, `Preloading scene ${i + 1}/${warmupFrames}`);
            if (renderer && scene && camera) renderer.render(scene, camera);
            await waitForAnimationFrame();
        }
    }

    if (token !== loadingRunToken) return;
    if (loadingSkipRequested) {
        updateLoadingPanel(0.98, 'Skipping preload...');
    } else {
        updateLoadingPanel(1, 'Ready.');
    }
    await delayMs(120);
    if (token !== loadingRunToken) return;
    beginGameplayAfterLoading(token);
}

function playTone(freq, duration, type = 'sine', vol = 0.1, detune = 0) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    osc.detune.value = detune;
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

function playKnock() {
    const now = audioCtx.currentTime;
    for (let i = 0; i < 3; i++) {
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let s = 0; s < data.length; s++) {
            data[s] = (Math.random() * 2 - 1) * Math.exp(-s / (audioCtx.sampleRate * 0.008));
        }
        const src = audioCtx.createBufferSource();
        src.buffer = buf;
        const g = audioCtx.createGain();
        const bq = audioCtx.createBiquadFilter();
        bq.type = 'lowpass';
        bq.frequency.value = 800;
        g.gain.setValueAtTime(0.6, now + i * 0.25);
        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.25 + 0.15);
        src.connect(bq);
        bq.connect(g);
        g.connect(masterGain);
        src.start(now + i * 0.25);
    }
}

function playCreak() {
    if (sleepEndingActive) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, audioCtx.currentTime);
    osc.frequency.linearRampToValueAtTime(40, audioCtx.currentTime + 0.8);
    gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.8);
}

function playHeartbeat() {
    if (sleepEndingActive) return;
    for (let i = 0; i < 2; i++) {
        setTimeout(() => playTone(40, 0.2, 'sine', 0.15), i * 200);
    }
}

function playWhisper() {
    if (sleepEndingActive) return;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let s = 0; s < data.length; s++) {
        data[s] = (Math.random() * 2 - 1) * 0.02 * Math.sin(s / (audioCtx.sampleRate * 0.3));
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const bq = audioCtx.createBiquadFilter();
    bq.type = 'bandpass';
    bq.frequency.value = 2000;
    bq.Q.value = 5;
    const g = audioCtx.createGain();
    g.gain.value = 0.3;
    src.connect(bq);
    bq.connect(g);
    g.connect(masterGain);
    src.start();
}

function playEarWhisper() {
    if (sleepEndingActive) return;
    const duration = 0.7 + Math.random() * 0.45;
    const len = Math.max(1, Math.floor(audioCtx.sampleRate * duration));
    const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / len;
        const env = Math.sin(Math.min(1, t) * Math.PI);
        data[i] = (Math.random() * 2 - 1) * 0.032 * env;
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 2350;
    bp.Q.value = 6.5;
    const gain = audioCtx.createGain();
    gain.gain.value = 0.26;

    if (typeof audioCtx.createStereoPanner === 'function') {
        const pan = audioCtx.createStereoPanner();
        pan.pan.value = Math.random() < 0.5 ? -0.86 : 0.86;
        src.connect(bp);
        bp.connect(gain);
        gain.connect(pan);
        pan.connect(masterGain);
    } else {
        src.connect(bp);
        bp.connect(gain);
        gain.connect(masterGain);
    }

    src.start();
}

function playDrone(freq = 55, dur = 4) {
    if (sleepEndingActive) return;
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc1.type = 'sine';
    osc1.frequency.value = freq;
    osc2.type = 'sine';
    osc2.frequency.value = freq + 1.5;
    gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(masterGain);
    osc1.start();
    osc2.start();
    osc1.stop(audioCtx.currentTime + dur);
    osc2.stop(audioCtx.currentTime + dur);
}

function playScream() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
    osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.5);
    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.2));
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const g2 = audioCtx.createGain();
    g2.gain.value = 0.3;
    src.connect(g2);
    g2.connect(masterGain);
    src.start();
}

function playGlassBreak() {
    const now = audioCtx.currentTime;
    const burst = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.9, audioCtx.sampleRate);
    const data = burst.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / audioCtx.sampleRate;
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * Math.exp(-t * 8) * (0.7 + Math.sin(i * 0.09) * 0.3);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = burst;
    const high = audioCtx.createBiquadFilter();
    high.type = 'highpass';
    high.frequency.value = 1200;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.55, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.9);
    src.connect(high);
    high.connect(g);
    g.connect(masterGain);
    src.start(now);

    // Falling shards.
    for (let i = 0; i < 9; i++) {
        const osc = audioCtx.createOscillator();
        const og = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1400 + Math.random() * 2600, now + i * 0.02);
        osc.frequency.exponentialRampToValueAtTime(300 + Math.random() * 300, now + i * 0.02 + 0.25);
        og.gain.setValueAtTime(0.03, now + i * 0.02);
        og.gain.exponentialRampToValueAtTime(0.001, now + i * 0.02 + 0.25);
        osc.connect(og);
        og.connect(masterGain);
        osc.start(now + i * 0.02);
        osc.stop(now + i * 0.02 + 0.25);
    }
}

function playBedRustle() {
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.2, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / audioCtx.sampleRate;
        data[i] = (Math.random() * 2 - 1) * 0.12 * Math.exp(-t * 2.8);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 900;
    const g = audioCtx.createGain();
    g.gain.value = 0.45;
    src.connect(lp);
    lp.connect(g);
    g.connect(masterGain);
    src.start();
}

function playMorningBirds() {
    for (let i = 0; i < 7; i++) {
        const t = i * 0.35;
        setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(900 + Math.random() * 500, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1400 + Math.random() * 500, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.22);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.22);
        }, t * 1000);
    }
}

function playPhoneBuzzSound() {
    if (sleepEndingActive || sleepTransitionActive || closetEndingActive || phoneEndingActive || endingTriggered) return;
    // Original synthetic buzz style.
    for (let i = 0; i < 2; i++) {
        const when = audioCtx.currentTime + i * 0.12;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(170, when);
        osc.frequency.exponentialRampToValueAtTime(130, when + 0.08);
        gain.gain.setValueAtTime(0.03, when);
        gain.gain.exponentialRampToValueAtTime(0.001, when + 0.1);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(when);
        osc.stop(when + 0.1);
    }
}

function playPhoneStaticVoice() {
    const now = audioCtx.currentTime;
    const duration = 3.1;
    const len = Math.max(1, Math.floor(audioCtx.sampleRate * duration));
    const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    let holdFrames = 0;
    let heldSample = 0;
    for (let i = 0; i < data.length; i++) {
        const t = i / audioCtx.sampleRate;
        if (holdFrames <= 0) {
            holdFrames = 1 + Math.floor(Math.random() * 8);
            heldSample = (Math.random() * 2 - 1) * 0.055;
        }
        holdFrames--;
        const choppyGate = 0.55 + 0.45 * Math.sign(Math.sin(t * 22 + Math.sin(t * 4.2) * 2));
        const hiss = (Math.random() * 2 - 1) * 0.018;
        data[i] = (heldSample * choppyGate + hiss) * (0.82 + Math.sin(t * 3.3) * 0.18);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 280;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1180;
    bp.Q.value = 3.8;
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 2600;
    const tremolo = audioCtx.createOscillator();
    const tremoloGain = audioCtx.createGain();
    tremolo.frequency.value = 7.2;
    tremoloGain.gain.value = 420;
    tremolo.connect(tremoloGain);
    tremoloGain.connect(bp.frequency);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.2, now + 0.04);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    src.connect(hp);
    hp.connect(bp);
    bp.connect(lp);
    lp.connect(g);
    g.connect(masterGain);
    src.start(now);
    src.stop(now + duration + 0.05);
    tremolo.start(now);
    tremolo.stop(now + duration + 0.05);

    [0.24, 0.8, 1.35, 2.0, 2.45].forEach((offset, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const startFreq = 110 + i * 37 + Math.random() * 15;
        osc.type = i % 2 === 0 ? 'sawtooth' : 'triangle';
        osc.frequency.setValueAtTime(startFreq, now + offset);
        osc.frequency.exponentialRampToValueAtTime(Math.max(45, startFreq * (0.42 + Math.random() * 0.18)), now + offset + 0.42);
        osc.detune.setValueAtTime(-650 + Math.random() * 220, now + offset);
        gain.gain.setValueAtTime(0.018, now + offset);
        gain.gain.exponentialRampToValueAtTime(0.001, now + offset + 0.44);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(now + offset);
        osc.stop(now + offset + 0.44);
    });
}

function sanitizeSpeechText(text) {
    return String(text || '')
        .replace(/["']/g, '')
        .replace(/[.,!?]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

function getPhoneLineSubtitleDuration(text) {
    const spoken = sanitizeSpeechText(text);
    const seconds = Math.max(1.8, Math.min(6.2, (spoken.length || 8) * 0.19));
    return Math.round(seconds * 1000 + 550);
}

function playDampWhisperLayer(duration = 1.8) {
    const now = audioCtx.currentTime;
    const len = Math.max(1, Math.floor(audioCtx.sampleRate * duration));
    const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / data.length;
        const env = Math.sin(Math.min(1, t) * Math.PI);
        const noise = (Math.random() * 2 - 1) * 0.08;
        data[i] = noise * env;
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 120;
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 620;
    lp.Q.value = 0.7;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.01, now);
    g.gain.linearRampToValueAtTime(0.028, now + 0.2);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);

    src.connect(hp);
    hp.connect(lp);
    lp.connect(g);
    g.connect(masterGain);
    src.start(now);
    src.stop(now + duration + 0.05);
}

function playScaryVoiceLine(text, source = 'general') {
    if (phoneEndingActive && source !== 'phone') return;
    if (!gameSettings.voice) return;
    const spoken = sanitizeSpeechText(text);
    if (!spoken) {
        playDampWhisperLayer(0.7);
        return;
    }

    playDampWhisperLayer(Math.max(1.2, Math.min(3.2, spoken.length * 0.11)));
    playTone(62, 1.1, 'sawtooth', 0.012, -400);

    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis;
    const utter = new SpeechSynthesisUtterance(spoken);
    const voices = synth.getVoices();
    const voice = voices.find(v => /en/i.test(v.lang) && /(zira|hazel|samantha|google us english|aria|david)/i.test(v.name))
        || voices.find(v => /en/i.test(v.lang))
        || null;

    if (voice) utter.voice = voice;
    utter.lang = voice ? voice.lang : 'en-US';
    utter.rate = 0.56;
    utter.pitch = 0.22;
    utter.volume = Math.max(0.05, Math.min(0.24, gameSettings.masterVolume * 0.35));
    synth.cancel();
    synth.speak(utter);
}

function playUncannyPhoneVoiceLine(text, source = 'general') {
    if (phoneEndingActive && source !== 'phone') return;
    const spoken = sanitizeSpeechText(text);
    const durationHint = Math.max(1.1, Math.min(3.4, (spoken.length || 8) * 0.12));

    playPhoneStaticVoice();
    playDampWhisperLayer(durationHint);
    playTone(48 + Math.random() * 10, Math.max(1.35, durationHint * 0.82), 'sawtooth', 0.01, -900 + Math.random() * 150);

    if (!gameSettings.voice) return;
    if (!spoken || !('speechSynthesis' in window)) return;

    const synth = window.speechSynthesis;
    const voices = synth.getVoices();
    const voice = voices.find(v => /en/i.test(v.lang) && /(david|zira|hazel|aria|google us english|samantha|mark|alex)/i.test(v.name))
        || voices.find(v => /en/i.test(v.lang))
        || null;

    const utter = new SpeechSynthesisUtterance(spoken);
    if (voice) utter.voice = voice;
    utter.lang = voice ? voice.lang : 'en-US';
    utter.rate = 0.34 + Math.random() * 0.05;
    utter.pitch = 0.03 + Math.random() * 0.06;
    utter.volume = Math.max(0.05, Math.min(0.22, gameSettings.masterVolume * 0.28));
    synth.cancel();
    synth.speak(utter);
}

let scene, camera, renderer, clock;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let yaw = 0, pitch = 0;
let gameStarted = false;
let phase = 0;
let gameTime = 0;
let doorMesh, doorHingeGroup, windowMesh, windowFigure, ceilingLight, lampLight;
let lightFlickering = false;
let knockTimer = 0, nextKnockTime = 12;
let figureVisible = false;
let figureOpacity = 0;
let breathingRate = 0;
let wallWritings = [];
let furnitureObjects = [];
let mirrorCamera, mirrorTarget, mirrorMesh;
let mirrorInteractMesh;
let shadowFigure;
let radioMesh;
let closetDoor, closetOpen = false;
let playerHeight = 1.6;
let headBob = 0;
let isMoving = false;
const walkingAudio = new Audio('./walking.mp3');
walkingAudio.loop = true;
walkingAudio.volume = 0.5;

const runningAudio = new Audio('./running.mp3');
runningAudio.loop = true;
runningAudio.volume = 0.6;
let doorAttempts = 0;
let doorUnlocked = false;
let doorOpened = false;
let doorOpenAngle = 0;
let lookingAtDoor = false, lookingAtWindow = false;
const NORMAL_PHASE_TIMERS = { 1: 10, 2: 30, 3: 55, 4: 80, 5: 110, 6: 140, 7: 170, 8: 200, 9: 225 };
const NIGHTMARE_PHASE_TIMERS = { 1: 7, 2: 20, 3: 36, 4: 55, 5: 78, 6: 102, 7: 128, 8: 158, 9: 186 };
let phaseTimers = { ...NORMAL_PHASE_TIMERS };
let endingTriggered = false;
let ambientInterval;
let figureInRoom = false;
let tvMesh, tvOn = false;
let writings = [];
let collisionBoxes = [];
let ambientLight, moonLight, morningSunLight;
let flashlightMesh, flashlightLight, flashlightTarget;
let flashlightHeld = false, flashlightOn = false;
let blackoutTriggered = false;
let flashlightHintLight;
let flashlightFillLight;
let flashlightLookAttempts = 0;
let bedGroupRef;
let phoneMesh, phoneScreenMat, phoneLight;
let phoneBuzzActiveTimer = 0;
let phoneAnsweredOnce = false;
let sprintHeld = false;
let interactKeyHeld = false;
let gamePaused = false;
let bedHoldSeconds = 0;
let closetHoldSeconds = 0;
const closetHoldRequired = 1.8;
let sleepEndingActive = false;
let sleepTransitionActive = false;
let closetEndingActive = false;
let phoneEndingActive = false;
let dialogueSourceLock = null;
let houseLightSwitchMesh, houseLightSwitchLever;
let lampInteractMesh, lampBulbMat;
let houseLightsOn = true;
let lampOn = true;
let windowExteriorGroup;
let windowExteriorGroundMat, windowExteriorGrassMat, windowExteriorHillMat, windowExteriorSkyMat;
let windowExteriorTreeLeafMat, windowExteriorTreeTrunkMat;
let windowExteriorAmbient, windowExteriorSun;
let mobileControlsReady = false;
let mobileMoveTouchId = null;
let mobileLookTouchId = null;
let mobileMoveVectorX = 0;
let mobileMoveVectorY = 0;
let mobileLookLastX = 0;
let mobileLookLastY = 0;
let currentGameMode = 'normal';
let nightmareActive = false;
let nightmareWhisperTimer = 0;
let nightmareKnockBurstTimer = 0;
let nightmareDarknessTimer = 0;
let flashlightBattery = 1;
let flashlightBatteryDrainDuration = 42;
let flashlightBatteryNotifiedDead = false;
let nightmareBatteryMeshes = [];
let wallEndingActive = false;
let wallEndingTriggered = false;
let inventoryOpen = false;
let gameboyActive = false;
let gameboyHeld = false;
let gameboyMesh;
let snakeCanvas, snakeCtx, snakeInterval;
let snakeDir = {x:1,y:0}, snakeBody = [], snakeFood = {}, snakeScore = 0, snakeAlive = true;
let inventory = [];
let gameStartInProgress = false;
let loadingSkipRequested = false;
let loadingRunToken = 0;
let loadingProgressValue = 0;

const DOM = {};
function cacheDOM() {
    DOM.overlay = document.getElementById('overlay');
    DOM.pauseOverlay = document.getElementById('pause-overlay');
    DOM.batteryHud = document.getElementById('battery-hud');
    DOM.loadingPanel = document.getElementById('loading-panel');
    DOM.loadingStage = document.getElementById('loading-stage');
    DOM.loadingBarFill = document.getElementById('loading-bar-fill');
    DOM.loadingPercent = document.getElementById('loading-percent');
    DOM.loadingSkipButton = document.getElementById('loading-skip-btn');
    DOM.inventoryBar = document.getElementById('inventory-bar');
    DOM.gameboyOverlay = document.getElementById('gameboy-overlay');
    DOM.snakeCanvas = document.getElementById('snake-canvas');
    DOM.gameboyScore = document.getElementById('gameboy-score');
    DOM.horrorGrain = document.getElementById('horror-grain');
    DOM.sanityIndicator = document.getElementById('sanity-indicator');
    DOM.vignette = document.getElementById('vignette');
    DOM.staticOverlay = document.getElementById('static-overlay');
    DOM.bloodOverlay = document.getElementById('blood-overlay');
    DOM.dialogue = document.getElementById('dialogue');
    DOM.thought = document.getElementById('thought');
    DOM.interactPrompt = document.getElementById('interact-prompt');
}

const NIGHTMARE_WHISPERS = [
    "You're not alone in here.","I can see you.","Don't turn around.","It's right behind you.",
    "The walls are watching.","You shouldn't have come here.","There's something under the bed.",
    "Can you hear it breathing?","It knows your name.","The door was never locked... for them.",
    "You can't leave.","It's inside the walls.","Don't look at the mirror.","Something moved.",
    "The shadows are wrong.","It's getting closer.","You smell like fear.","Run. No... don't.",
    "The ceiling is dripping.","That sound... was it you?","Your reflection blinked.",
    "It's in the closet.","The knocking isn't from outside.","You invited it in.",
    "There's someone in the corner.","The bed is breathing.","It feeds on your fear.",
    "You forgot to lock the door.","The walls are getting closer.","It's watching through the window.",
    "Don't close your eyes.","Something is wrong with the mirror.","The floor is warm.",
    "It's been here the whole time.","You can feel it staring.","The air tastes like copper.",
    "Something brushed your neck.","The light won't save you.","It's learning your patterns.",
    "You're dreaming... aren't you?","The phone is ringing again.","Nobody called.",
    "The static is a voice.","Count the shadows. There's one too many.","It moved when you blinked.",
    "The door handle is turning.","Something is scratching from inside the wall.",
    "Your heartbeat is too loud.","It can hear your thoughts.","The carpet is wet.",
    "That wasn't the wind.","The lamp flickered on its own.","Something is in the vent.",
    "The picture frame is crooked again.","You didn't close that drawer.","The closet door is ajar.",
    "There are fingerprints on the window.","The TV turned on by itself.","You're being watched.",
    "It's hungry.","The shadows don't match the furniture.","Something dripped on your shoulder.",
    "The room is smaller than before.","You can't remember entering.","The clock stopped.",
    "There are too many footsteps.","The whispers are getting louder.","It's inside you.",
    "You left the light on... didn't you?","The bed sheets moved.","Something is under the desk.",
    "The mirror shows someone else.","Your hands are shaking.","The air is thick.",
    "It's patient.","You can't scream.","The walls are pulsing.","Something is in the ceiling.",
    "The door is breathing.","You're not in your room anymore.","The carpet has teeth.",
    "It knows you're afraid.","The window won't open.","Something is growing in the corner.",
    "The light is dying.","You can hear it chewing.","The phone is calling itself.",
    "There are eyes in the wallpaper.","The bed is sinking.","It's been three hours... or three days.",
    "The doorknob is ice cold.","Something is tapping on the glass.","You're bleeding.",
    "The mirror is fogging up.","There are handprints on the ceiling.","It's mimicking your voice.",
    "The shadows are moving independently.","Something crawled under the bed.",
    "The closet is deeper than it should be.","You can smell something rotting.",
    "The walls are sweating.","It's standing right behind you.","The floor is soft.",
    "Something is breathing in the vent.","The picture is different now.","You're sinking.",
    "The room is tilting.","It's in the reflection.","The carpet is crawling.",
    "Something touched your hand.","The light switch doesn't work anymore.","It's laughing.",
    "You can hear your name.","The bed is vibrating.","Something is in the pillow.",
    "The window is cracking.","There are scratches on the door.","It's getting warmer.",
    "The shadows have fingers.","Something is dripping from the ceiling.","You're not breathing right.",
    "The phone screen shows your face... but wrong.","It's been watching since you arrived.",
    "The knocking is coming from inside.","Something is wrong with the floor.",
    "The mirror cracked.","You can feel it in your chest.","The room remembers.",
    "It was always here.","You just didn't notice.","The walls have ears.",
    "Something is whispering your name.","The bed is cold.","It's feeding.",
    "The door is locked from the outside.","Something is in the mattress.",
    "The lamp is getting dimmer.","You can hear scratching.","It's in the dark.",
    "The closet smells wrong.","Something is watching from the vent.","You're trapped.",
    "The window shows a different room.","It's getting louder.","The floor is breathing.",
    "Something is wrong with the walls.","The ceiling is lower.","It's almost time.",
    "You can't wake up.","The bed is moving.","Something is in the sheets.",
    "The mirror shows the room empty.","It's inside the phone.","The static is screaming.",
    "Something is wrong with the light.","The shadows are reaching.","You're not safe.",
    "It's in the walls.","The door is bulging.","Something is trying to get in.",
    "The window is bleeding.","It's in the floor.","The room is shrinking.",
    "Something is wrong with you.","The mirror is watching.","It's almost here.",
    "You can feel it in the air.","The bed is alive.","Something is in the corner.",
    "The walls are closing in.","It's behind the door.","The light is wrong.",
    "Something is in the ceiling.","The floor is moving.","It's everywhere.",
    "You can't escape.","The room knows.","Something is coming.","It's here.",
    "The darkness is alive.","You're not alone.","Something changed.",
    "The air is wrong.","It's watching.","The silence is too loud.",
    "Something is different.","The room shifted.","It's closer now.",
    "You can feel eyes on you.","The temperature dropped.","Something breathed on your neck.",
    "The shadows are wrong.","It moved.","The door creaked.","Something fell.",
    "The mirror rippled.","It's awake.","The walls remember what happened here.",
    "Something is scratching behind the wallpaper.","The bed frame groaned.",
    "It's counting down.","The phone buzzed but the screen showed static.",
    "Something is wrong with the ceiling fan.","The rug moved.","It's in the carpet fibers.",
    "The doorknob rattled.","Something is breathing in the closet.",
    "The picture frame fell.","It's getting colder.","The window fogged up from the outside.",
    "Something is tapping in morse code.","The lamp shade is spinning slowly.",
    "It knows you found the lantern.","The fluid won't last.",
    "Something is humming.","The walls have veins.","It's in the wiring.",
    "The floor tiles are loose.","Something is growing under the bed.",
    "The door has new scratches.","It's memorizing your route.",
    "Something is wrong with the clock.","The mirror shows tomorrow.",
    "It's in the static.","The phone knows.","Something is in the drawer.",
    "The bed remembers everyone who slept here.","It's patient. It can wait forever.",
    "Something is wrong with gravity.","The room has more corners than before.",
    "It's in the spaces between.","The darkness has texture.",
    "Something is living in the lamp.","The ceiling has a heartbeat.",
    "It's older than the house.","The walls are paper thin.",
    "Something is wrong with the air.","The floor has a pulse.",
    "It's been here longer than you.","The room is a mouth.",
    "Something is digesting.","The walls are teeth.",
    "It's swallowing.","You're inside it.","The room is alive.",
    "Something is wrong with everything.","It was never a room.",
    "You're the intruder.","It's home.","The bedroom is hungry.",
    "Something is very wrong.","Don't look up.","Don't look down.",
    "Don't breathe.","Don't move.","Don't think.","Don't remember.",
    "It's reading your mind.","The thoughts aren't yours.",
    "Something planted a memory.","The fear is a flavor.",
    "It's tasting you.","The room is digesting you slowly.",
    "Something is replacing your thoughts.","The whispers are your voice.",
    "It's you. It was always you.","The monster is inside.",
    "Something is wearing your face.","The reflection moved first."
];

const ROOM = { w: 8, h: 3.2, d: 7 };
const loader = new THREE.TextureLoader();

function createCanvasTexture(w, h, drawFn) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    drawFn(ctx, w, h);
    const tex = new THREE.CanvasTexture(c);
    tex.minFilter = THREE.LinearFilter;
    return tex;
}

function woodTexture() {
    return createCanvasTexture(512, 512, (ctx, w, h) => {
        // Base wood color with a subtle gradient
        const bgGrad = ctx.createLinearGradient(0, 0, w, h);
        bgGrad.addColorStop(0, '#4a3424');
        bgGrad.addColorStop(1, '#322216');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, w, h);
        
        // Add dense, overlapping wood grains
        ctx.globalAlpha = 0.5;
        for (let i = 0; i < 150; i++) {
            ctx.strokeStyle = `rgba(${20 + Math.random()*20}, ${10 + Math.random()*15}, ${5 + Math.random()*10}, ${0.1 + Math.random()*0.3})`;
            ctx.lineWidth = 1 + Math.random() * 4;
            ctx.beginPath();
            let y = Math.random() * h;
            ctx.moveTo(0, y);
            for (let x = 0; x <= w; x += 15) {
                y += (Math.random() - 0.5) * 4;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // Add knots
        ctx.globalAlpha = 0.7;
        for (let i = 0; i < 5; i++) {
            const kx = Math.random() * w;
            const ky = Math.random() * h;
            const kr = 5 + Math.random() * 15;
            ctx.fillStyle = `rgba(30, 20, 10, ${0.4 + Math.random()*0.3})`;
            ctx.beginPath();
            ctx.ellipse(kx, ky, kr, kr * (2 + Math.random()*3), 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Rings around knots
            for (let r = 1; r < 4; r++) {
                ctx.strokeStyle = `rgba(20, 10, 5, ${0.2 + Math.random()*0.2})`;
                ctx.lineWidth = 1 + Math.random();
                ctx.beginPath();
                ctx.ellipse(kx, ky, kr + r*4, (kr + r*4) * (2 + Math.random()), 0, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        ctx.globalAlpha = 1.0;
    });
}

function wallTexture(color = '#45403a') {
    return createCanvasTexture(512, 512, (ctx, w, h) => {
        // Base plaster color
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, w, h);
        
        // Add plaster/stucco texture noise
        for (let i = 0; i < 15000; i++) {
            const x = Math.random() * w;
            const y = Math.random() * h;
            // Mix of light and dark specks for bumpiness
            const isDark = Math.random() > 0.5;
            ctx.fillStyle = isDark ? `rgba(0,0,0,${Math.random() * 0.08})` : `rgba(255,255,255,${Math.random() * 0.06})`;
            const size = 1 + Math.random() * 2;
            ctx.fillRect(x, y, size, size);
        }
        
        // Add faint water damage/grime streaks coming down
        for (let i = 0; i < 15; i++) {
            ctx.strokeStyle = `rgba(30,25,20,${0.02 + Math.random()*0.04})`;
            ctx.lineWidth = 10 + Math.random() * 40;
            ctx.beginPath();
            const sx = Math.random() * w;
            ctx.moveTo(sx, 0);
            ctx.lineTo(sx + (Math.random() - 0.5) * 20, h * (0.3 + Math.random() * 0.7));
            ctx.stroke();
        }
    });
}

function carpetTexture() {
    return createCanvasTexture(512, 512, (ctx, w, h) => {
        ctx.fillStyle = '#26221d'; // Deeper, richer base color
        ctx.fillRect(0, 0, w, h);
        
        // Dense carpet fibers
        for (let i = 0; i < 30000; i++) {
            const r = 30 + Math.random() * 25;
            const g = 25 + Math.random() * 20;
            const b = 20 + Math.random() * 15;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.4 + Math.random()*0.4})`;
            
            const x = Math.random() * w;
            const y = Math.random() * h;
            // Draw tiny overlapping ellipses to look like tufts
            ctx.beginPath();
            ctx.ellipse(x, y, 1.5, 2.5, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Add slight large-scale unevenness (wear/lighting variation)
        const grad = ctx.createRadialGradient(w/2, h/2, w/4, w/2, h/2, w);
        grad.addColorStop(0, 'rgba(255,255,255,0.02)');
        grad.addColorStop(1, 'rgba(0,0,0,0.15)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
    });
}

function ceilingTexture() {
    return createCanvasTexture(512, 512, (ctx, w, h) => {
        ctx.fillStyle = '#d5cebd';
        ctx.fillRect(0, 0, w, h);
        
        // Popcorn ceiling texture
        for (let i = 0; i < 12000; i++) {
            const x = Math.random() * w;
            const y = Math.random() * h;
            const isHighlight = Math.random() > 0.7;
            ctx.fillStyle = isHighlight ? `rgba(255,255,255,${0.1 + Math.random()*0.1})` : `rgba(0,0,0,${Math.random()*0.05})`;
            const size = 1 + Math.random() * 3;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI*2);
            ctx.fill();
        }
    });
}

function morningFieldTexture() {
    return createCanvasTexture(512, 256, (ctx, w, h) => {
        const sky = ctx.createLinearGradient(0, 0, 0, h * 0.55);
        sky.addColorStop(0, '#a8d7ff');
        sky.addColorStop(1, '#e6f4ff');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, w, h * 0.55);

        const grass = ctx.createLinearGradient(0, h * 0.55, 0, h);
        grass.addColorStop(0, '#6bb35b');
        grass.addColorStop(1, '#4b8a3d');
        ctx.fillStyle = grass;
        ctx.fillRect(0, h * 0.55, w, h * 0.45);

        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        for (let i = 0; i < 5; i++) {
            const x = 40 + i * 95 + Math.random() * 20;
            const y = 30 + Math.random() * 20;
            ctx.beginPath();
            ctx.arc(x, y, 18, 0, Math.PI * 2);
            ctx.arc(x + 18, y + 2, 14, 0, Math.PI * 2);
            ctx.arc(x - 16, y + 3, 13, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

function buildProceduralWardrobe(parentGroup) {
    const wTex = woodTexture();
    wTex.wrapS = wTex.wrapT = THREE.RepeatWrapping;
    const mat = new THREE.MeshStandardMaterial({ map: wTex, roughness: 0.58, metalness: 0.02 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x080604, roughness: 0.95 });
    const handleMat = new THREE.MeshStandardMaterial({ color: 0xb0a088, metalness: 0.65, roughness: 0.28 });

    const W = 1.2, H = 2.2, D = 0.6, t = 0.025;

    function addBox(w, h, d, m, x, y, z) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), m);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        parentGroup.add(mesh);
        return mesh;
    }

    addBox(W, H, t, mat, 0, H / 2, -D / 2 + t / 2);
    addBox(t, H, D, mat, -W / 2 + t / 2, H / 2, 0);
    addBox(t, H, D, mat, W / 2 - t / 2, H / 2, 0);
    addBox(W - t * 2, t, D, mat, 0, H - t / 2, 0);
    addBox(W - t * 2, t, D, mat, 0, t / 2, 0);

    addBox(W + 0.04, 0.055, D + 0.03, mat, 0, H + 0.018, 0);
    addBox(W + 0.02, 0.07, D + 0.015, mat, 0, -0.01, 0);
    addBox(t / 2, H - t * 2, D - t, mat, 0, H / 2, t / 2);

    const doorGap = 0.028;
    const doorW = (W - t * 2 - doorGap - 0.012) / 2;
    const doorH = H - t * 2 - 0.02;
    const doorD = 0.028;
    const doorZ = D / 2 - doorD / 2 - 0.003;

    // Dark backing makes the center split and panel depth read clearly.
    addBox(W - t * 2 - 0.02, doorH - 0.02, 0.01, darkMat, 0, H / 2, D / 2 - 0.025);

    [-1, 1].forEach(side => {
        const cx = side * (doorW / 2 + doorGap / 2);
        addBox(doorW, doorH, doorD, mat, cx, H / 2, doorZ);

        const pw = doorW - 0.1;
        addBox(pw, doorH * 0.32, 0.006, mat, cx, H / 2 + doorH * 0.22, doorZ + doorD / 2 - 0.01);
        addBox(pw, doorH * 0.42, 0.006, mat, cx, H / 2 - doorH * 0.17, doorZ + doorD / 2 - 0.01);

        const handleX = cx + (-side) * (doorW / 2 - 0.07);
        const handleY = H / 2;
        const handleZ = doorZ + doorD / 2 + 0.018;

        const handleBar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.009, 0.009, 0.24, 10),
            handleMat
        );
        handleBar.position.set(handleX, handleY, handleZ);
        handleBar.castShadow = true;
        parentGroup.add(handleBar);

        [-0.075, 0.075].forEach(offsetY => {
            const mount = new THREE.Mesh(
                new THREE.CylinderGeometry(0.005, 0.005, 0.03, 10),
                handleMat
            );
            mount.rotation.x = Math.PI / 2;
            mount.position.set(handleX, handleY + offsetY, handleZ - 0.012);
            mount.castShadow = true;
            parentGroup.add(mount);
        });
    });

    // Front divider to sell the "two-door closet" shape.
    addBox(doorGap * 0.45, doorH - 0.02, doorD + 0.006, darkMat, 0, H / 2, doorZ + 0.002);
    addBox(W - t * 2 - 0.01, t / 2, D - t, mat, 0, H * 0.6, t / 2);
}

function init() {
    cacheDOM();
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.Fog(0x050505, 8, 18);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 50);
    camera.position.set(0, playerHeight, 2);

    const q = QUALITY_PRESETS[gameSettings.quality] || QUALITY_PRESETS.high;
    renderer = new THREE.WebGLRenderer({ antialias: q.antialias, powerPreference: 'high-performance' });
    renderer.setPixelRatio(q.pixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = q.shadowMap;
    if (q.shadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = q.toneExposure;
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    buildRoom();
    buildFurniture();
    buildDoor();
    buildWindow();
    buildLighting();
    buildFlashlight();
    buildShadowFigure();
    buildTV();

    window.addEventListener('resize', onResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('click', onClick);
    setupMobileControls();
}

function addCollisionBox(x, z, width, depth) {
    collisionBoxes.push({
        minX: x - width / 2,
        maxX: x + width / 2,
        minZ: z - depth / 2,
        maxZ: z + depth / 2
    });
}

function canMoveTo(x, z) {
    const wallMargin = 0.35;
    const playerRadius = 0.24;
    if (x < -ROOM.w / 2 + wallMargin || x > ROOM.w / 2 - wallMargin) return false;
    if (z < -ROOM.d / 2 + wallMargin || z > ROOM.d / 2 - wallMargin) return false;

    for (const box of collisionBoxes) {
        if (
            x + playerRadius > box.minX &&
            x - playerRadius < box.maxX &&
            z + playerRadius > box.minZ &&
            z - playerRadius < box.maxZ
        ) {
            return false;
        }
    }
    return true;
}

function buildRoom() {
    const floorTex = carpetTexture();
    floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
    floorTex.repeat.set(4, 4);
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(ROOM.w, ROOM.d),
        new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const ceilTex = ceilingTexture();
    const ceiling = new THREE.Mesh(
        new THREE.PlaneGeometry(ROOM.w, ROOM.d),
        new THREE.MeshStandardMaterial({ map: ceilTex, roughness: 0.8 })
    );
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    const wallMat = new THREE.MeshStandardMaterial({ map: wallTexture(), roughness: 0.85 });
    const wallMatDark = new THREE.MeshStandardMaterial({ map: wallTexture('#3d3835'), roughness: 0.85 });

    // Back wall
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.h), wallMat);
    backWall.position.set(0, ROOM.h / 2, -ROOM.d / 2);
    backWall.receiveShadow = true;
    scene.add(backWall);

    // Front wall (with door)
    const frontWallL = new THREE.Mesh(new THREE.PlaneGeometry(2.5, ROOM.h), wallMat);
    frontWallL.position.set(-2.75, ROOM.h / 2, ROOM.d / 2);
    frontWallL.rotation.y = Math.PI;
    frontWallL.receiveShadow = true;
    scene.add(frontWallL);

    const frontWallR = new THREE.Mesh(new THREE.PlaneGeometry(4.5, ROOM.h), wallMat);
    frontWallR.position.set(1.75, ROOM.h / 2, ROOM.d / 2);
    frontWallR.rotation.y = Math.PI;
    frontWallR.receiveShadow = true;
    scene.add(frontWallR);

    const frontWallTop = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.7), wallMat);
    frontWallTop.position.set(-0.75, ROOM.h - 0.35, ROOM.d / 2);
    frontWallTop.rotation.y = Math.PI;
    scene.add(frontWallTop);

    // Left wall (thick box to prevent any see-through at edges)
    const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.08, ROOM.h, ROOM.d), wallMatDark);
    leftWall.position.set(-ROOM.w / 2 + 0.04, ROOM.h / 2, 0);
    leftWall.receiveShadow = true;
    scene.add(leftWall);

    // Right wall (with window) built as solid segments to avoid see-through leaks.
    const rightWallThickness = 0.08;
    const addRightWallSegment = (width, height, y, z) => {
        const seg = new THREE.Mesh(
            new THREE.BoxGeometry(rightWallThickness, height, width),
            wallMat
        );
        seg.position.set(ROOM.w / 2 - rightWallThickness / 2, y, z);
        seg.receiveShadow = true;
        scene.add(seg);
    };

    addRightWallSegment(ROOM.d, 0.7, ROOM.h - 0.35, 0);
    addRightWallSegment(ROOM.d, 0.8, 0.4, 0);
    addRightWallSegment(1.5, 1.7, 1.65, -1.75);
    addRightWallSegment(1.5, 1.7, 1.65, 1.75);
    addRightWallSegment(1.0, 1.7, 1.65, -3.0);
    addRightWallSegment(1.0, 1.7, 1.65, 3.0);

    // Inner jamb strips around the opening help hide edge artifacts at steep angles.
    [
        { s: [rightWallThickness, 1.7, 0.06], p: [ROOM.w / 2 - rightWallThickness / 2, 1.65, -2] },
        { s: [rightWallThickness, 1.7, 0.06], p: [ROOM.w / 2 - rightWallThickness / 2, 1.65, 2] },
        { s: [rightWallThickness, 0.06, 4], p: [ROOM.w / 2 - rightWallThickness / 2, 2.5, 0] },
        { s: [rightWallThickness, 0.06, 4], p: [ROOM.w / 2 - rightWallThickness / 2, 0.8, 0] },
    ].forEach(edge => {
        const m = new THREE.Mesh(new THREE.BoxGeometry(...edge.s), wallMat);
        m.position.set(...edge.p);
        m.receiveShadow = true;
        scene.add(m);
    });

    // Baseboard
    const bbMat = new THREE.MeshStandardMaterial({ color: 0x1a1410, roughness: 0.7 });
    [
        { p: [0, 0.05, -ROOM.d/2 + 0.01], s: [ROOM.w, 0.1, 0.02], ry: 0 },
        { p: [-ROOM.w/2 + 0.01, 0.05, 0], s: [0.02, 0.1, ROOM.d], ry: 0 },
        { p: [ROOM.w/2 - 0.01, 0.05, 0], s: [0.02, 0.1, ROOM.d], ry: 0 },
    ].forEach(b => {
        const m = new THREE.Mesh(new THREE.BoxGeometry(...b.s), bbMat);
        m.position.set(...b.p);
        scene.add(m);
    });
}

function buildFurniture() {
    const woodTex = woodTexture();
    const woodMat = new THREE.MeshStandardMaterial({ map: woodTex, roughness: 0.7 });
    const sheetMat = new THREE.MeshStandardMaterial({ 
        color: 0x8a8070, 
        roughness: 0.9,
        bumpScale: 0.02
    });
    // Create a procedural fabric texture for the sheets
    const fabricTex = createCanvasTexture(256, 256, (ctx, w, h) => {
        ctx.fillStyle = '#8a8070';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        for (let i = 0; i < w; i += 4) {
            ctx.fillRect(i, 0, 1, h);
            ctx.fillRect(0, i, w, 1);
        }
    });
    fabricTex.wrapS = fabricTex.wrapT = THREE.RepeatWrapping;
    fabricTex.repeat.set(4, 4);
    sheetMat.map = fabricTex;

    const pillowMat = new THREE.MeshStandardMaterial({ 
        color: 0xeae5d9, 
        roughness: 0.95
    });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x1a1510, roughness: 0.8 });

    // Bed frame
    const bedGroup = new THREE.Group();
    const bedBase = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.3, 1.6), woodMat);
    bedBase.position.y = 0.25;
    bedBase.castShadow = true;
    bedGroup.add(bedBase);

    // Mattress
    const mattress = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.2, 1.4),
        new THREE.MeshStandardMaterial({ color: 0x555045, roughness: 0.95 })
    );
    mattress.position.y = 0.5;
    bedGroup.add(mattress);

    // Sheet (draped over mattress)
    const sheetGroup = new THREE.Group();
    const sheetTop = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.04, 1.42), sheetMat);
    sheetTop.position.set(0.2, 0.61, 0);
    sheetTop.castShadow = true;
    sheetTop.receiveShadow = true;
    sheetGroup.add(sheetTop);
    
    // Side drapes
    const sheetSideL = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.25, 0.04), sheetMat);
    sheetSideL.position.set(0.2, 0.49, -0.71);
    sheetSideL.rotation.x = 0.1;
    sheetSideL.castShadow = true;
    sheetGroup.add(sheetSideL);
    
    const sheetSideR = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.25, 0.04), sheetMat);
    sheetSideR.position.set(0.2, 0.49, 0.71);
    sheetSideR.rotation.x = -0.1;
    sheetSideR.castShadow = true;
    sheetGroup.add(sheetSideR);
    
    const sheetBack = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25, 1.42), sheetMat);
    sheetBack.position.set(1.0, 0.49, 0);
    sheetBack.rotation.z = -0.1;
    sheetBack.castShadow = true;
    sheetGroup.add(sheetBack);
    
    bedGroup.add(sheetGroup);

    // Pillows (more realistic shapes using spheres scaled down on Y axis)
    const pillowGeo = new THREE.SphereGeometry(0.25, 16, 16);
    const pillow1 = new THREE.Mesh(pillowGeo, pillowMat);
    pillow1.scale.set(1, 0.35, 1.4);
    pillow1.position.set(-0.75, 0.65, -0.35);
    pillow1.rotation.z = 0.1; // Slightly angled against headboard
    pillow1.castShadow = true;
    pillow1.receiveShadow = true;
    bedGroup.add(pillow1);

    const pillow2 = new THREE.Mesh(pillowGeo, pillowMat);
    pillow2.scale.set(1, 0.35, 1.4);
    pillow2.position.set(-0.75, 0.65, 0.35);
    pillow2.rotation.z = 0.15;
    pillow2.rotation.x = 0.05; // Slightly messy
    pillow2.castShadow = true;
    pillow2.receiveShadow = true;
    bedGroup.add(pillow2);

    // Headboard
    const headboard = new THREE.Mesh(new THREE.BoxGeometry(0.08, 1, 1.6), woodMat);
    headboard.position.set(-1.12, 0.7, 0);
    headboard.castShadow = true;
    bedGroup.add(headboard);

    // Legs
    [[-1, 0.1, -0.7], [-1, 0.1, 0.7], [1, 0.1, -0.7], [1, 0.1, 0.7]].forEach(p => {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), woodMat);
        leg.position.set(...p);
        bedGroup.add(leg);
    });

    bedGroup.position.set(0, 0, -ROOM.d / 2 + 0.8);
    bedGroupRef = bedGroup;
    scene.add(bedGroup);
    furnitureObjects.push(bedGroup);
    addCollisionBox(0, -ROOM.d / 2 + 0.8, 2.25, 1.7);

    // Nightstand
    const nsGroup = new THREE.Group();
    const nsBody = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.55, 0.4), woodMat);
    nsBody.position.y = 0.275;
    nsBody.castShadow = true;
    nsGroup.add(nsBody);

    // Drawer
    const drawer = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.18, 0.02), darkMat);
    drawer.position.set(0, 0.35, 0.21);
    nsGroup.add(drawer);
    const knob = new THREE.Mesh(new THREE.SphereGeometry(0.02), new THREE.MeshStandardMaterial({ color: 0x888070, metalness: 0.5 }));
    knob.position.set(0, 0.35, 0.23);
    nsGroup.add(knob);

    nsGroup.position.set(-1.75, 0, -ROOM.d / 2 + 0.25);
    scene.add(nsGroup);
    furnitureObjects.push(nsGroup);
    addCollisionBox(-1.75, -ROOM.d / 2 + 0.25, 0.6, 0.5);

    // Lamp on nightstand
    const lampGroup = new THREE.Group();
    const lampBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.1, 0.04, 16),
        new THREE.MeshStandardMaterial({ color: 0x333025, metalness: 0.3 })
    );
    lampGroup.add(lampBase);

    const lampPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.015, 0.3, 8),
        new THREE.MeshStandardMaterial({ color: 0x444035, metalness: 0.4 })
    );
    lampPole.position.y = 0.17;
    lampGroup.add(lampPole);

    const lampShade = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.12, 0.15, 16, 1, true),
        new THREE.MeshStandardMaterial({ color: 0xaa9570, side: THREE.DoubleSide, roughness: 0.9 })
    );
    lampShade.position.y = 0.37;
    lampGroup.add(lampShade);

    lampBulbMat = new THREE.MeshStandardMaterial({ color: 0xffeecc, emissive: 0xffddaa, emissiveIntensity: 2 });
    const lampBulb = new THREE.Mesh(
        new THREE.SphereGeometry(0.03, 8, 8),
        lampBulbMat
    );
    lampBulb.position.y = 0.33;
    lampGroup.add(lampBulb);

    lampGroup.position.set(-1.75, 0.55, -ROOM.d / 2 + 0.25);
    scene.add(lampGroup);
    lampInteractMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 10, 10),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
    );
    lampInteractMesh.position.set(-1.75, 0.9, -ROOM.d / 2 + 0.25);
    scene.add(lampInteractMesh);
    addCollisionBox(-1.75, -ROOM.d / 2 + 0.25, 0.55, 0.55);

    // Desk
    const deskGroup = new THREE.Group();
    const deskTop = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.05, 0.6), woodMat);
    deskTop.position.y = 0.75;
    deskTop.castShadow = true;
    deskGroup.add(deskTop);

    [[-0.55, 0.375, -0.25], [-0.55, 0.375, 0.25], [0.55, 0.375, -0.25], [0.55, 0.375, 0.25]].forEach(p => {
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.75, 0.05), woodMat);
        l.position.set(...p);
        deskGroup.add(l);
    });

    deskGroup.position.set(2.5, 0, -ROOM.d / 2 + 0.5);
    scene.add(deskGroup);
    furnitureObjects.push(deskGroup);
    addCollisionBox(2.5, -ROOM.d / 2 + 0.5, 1.35, 0.8);

    // Phone on desk (beside lamp side)
    const phoneGroup = new THREE.Group();

    const phoneChassis = new THREE.Mesh(
        new THREE.BoxGeometry(0.155, 0.012, 0.076),
        new THREE.MeshStandardMaterial({ color: 0x0e0e0e, roughness: 0.35, metalness: 0.4 })
    );
    phoneGroup.add(phoneChassis);

    const phoneFrame = new THREE.Mesh(
        new THREE.BoxGeometry(0.16, 0.015, 0.08),
        new THREE.MeshPhysicalMaterial({ color: 0x1a1a1a, metalness: 0.85, roughness: 0.15, clearcoat: 0.4 })
    );
    phoneGroup.add(phoneFrame);

    phoneScreenMat = new THREE.MeshPhysicalMaterial({
        color: 0x080808,
        emissive: 0x5090cc,
        emissiveIntensity: 0.02,
        roughness: 0.08,
        metalness: 0.05,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05
    });
    const phoneScreen = new THREE.Mesh(new THREE.BoxGeometry(0.138, 0.003, 0.064), phoneScreenMat);
    phoneScreen.position.y = 0.009;
    phoneGroup.add(phoneScreen);

    const phoneCameraLens = new THREE.Mesh(
        new THREE.CylinderGeometry(0.005, 0.005, 0.004, 12),
        new THREE.MeshStandardMaterial({ color: 0x111122, metalness: 0.9, roughness: 0.1 })
    );
    phoneCameraLens.position.set(0.055, -0.009, -0.025);
    phoneGroup.add(phoneCameraLens);

    const phoneCameraRing = new THREE.Mesh(
        new THREE.TorusGeometry(0.006, 0.001, 6, 12),
        new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 })
    );
    phoneCameraRing.rotation.x = Math.PI / 2;
    phoneCameraRing.position.set(0.055, -0.008, -0.025);
    phoneGroup.add(phoneCameraRing);

    const phonePort = new THREE.Mesh(
        new THREE.BoxGeometry(0.015, 0.003, 0.005),
        new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.6, roughness: 0.3 })
    );
    phonePort.position.set(-0.078, 0, 0);
    phoneGroup.add(phonePort);
    phoneGroup.position.set(-0.28, 0.78, 0.22);
    deskGroup.add(phoneGroup);
    phoneMesh = phoneGroup;
    phoneMesh.userData.basePos = phoneGroup.position.clone();

    phoneLight = new THREE.PointLight(0x88bbff, 0, 1.5, 2.2);
    phoneLight.position.set(-0.28, 0.83, 0.22);
    deskGroup.add(phoneLight);

    // Game Boy on desk
    const gbGroup = new THREE.Group();
    const gbBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.015, 0.13),
        new THREE.MeshStandardMaterial({ color: 0x4a4a6a, roughness: 0.5, metalness: 0.1 })
    );
    gbGroup.add(gbBody);
    const gbScreen = new THREE.Mesh(
        new THREE.BoxGeometry(0.055, 0.002, 0.055),
        new THREE.MeshStandardMaterial({ color: 0x9bbc0f, emissive: 0x3a4a0f, emissiveIntensity: 0.3, roughness: 0.3 })
    );
    gbScreen.position.set(0, 0.009, -0.02);
    gbGroup.add(gbScreen);
    const gbDpad = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.003, 0.02),
        new THREE.MeshStandardMaterial({ color: 0x222233 })
    );
    gbDpad.position.set(0, 0.009, 0.035);
    gbGroup.add(gbDpad);
    const gbBtnA = new THREE.Mesh(
        new THREE.CylinderGeometry(0.005, 0.005, 0.003, 8),
        new THREE.MeshStandardMaterial({ color: 0x8a2244 })
    );
    gbBtnA.position.set(0.025, 0.009, 0.03);
    gbGroup.add(gbBtnA);
    const gbBtnB = new THREE.Mesh(
        new THREE.CylinderGeometry(0.005, 0.005, 0.003, 8),
        new THREE.MeshStandardMaterial({ color: 0x8a2244 })
    );
    gbBtnB.position.set(0.025, 0.009, 0.045);
    gbGroup.add(gbBtnB);
    gbGroup.position.set(0.15, 0.78, 0.22);
    gbGroup.rotation.y = Math.PI * 0.1;
    deskGroup.add(gbGroup);
    gameboyMesh = gbGroup;

    // Chair
    const chairGroup = new THREE.Group();
    const seat = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.04, 0.4), woodMat);
    seat.position.y = 0.45;
    chairGroup.add(seat);
    const back = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.5, 0.04), woodMat);
    back.position.set(0, 0.72, -0.18);
    chairGroup.add(back);
    [[-0.18, 0.22, -0.15], [-0.18, 0.22, 0.15], [0.18, 0.22, -0.15], [0.18, 0.22, 0.15]].forEach(p => {
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.44, 0.04), woodMat);
        l.position.set(...p);
        chairGroup.add(l);
    });
    chairGroup.position.set(2.5, 0, -ROOM.d / 2 + 1.2);
    scene.add(chairGroup);
    furnitureObjects.push(chairGroup);
    addCollisionBox(2.5, -ROOM.d / 2 + 1.2, 0.65, 0.6);

    // Wardrobe / Closet (left wall) using imported model
    const wardGroup = new THREE.Group();
    buildProceduralWardrobe(wardGroup);

    // Invisible interaction collider over both doors.
    closetDoor = new THREE.Mesh(
        new THREE.BoxGeometry(1.15, 2.05, 0.08),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
    );
    closetDoor.position.set(0, 1.08, 0.33);
    wardGroup.add(closetDoor);

    // Keep closet on left wall, with doors facing into room.
    wardGroup.position.set(-ROOM.w / 2 + 0.32, 0, 0.55);
    wardGroup.rotation.y = Math.PI / 2;
    wardGroup.userData.canShift = false;
    scene.add(wardGroup);
    furnitureObjects.push(wardGroup);
    addCollisionBox(-ROOM.w / 2 + 0.32, 0.55, 0.72, 1.28);

    // Wall-mounted Mirror near the closet (left side).
    const mirrorGroup = new THREE.Group();
    const frameDarkMat = new THREE.MeshStandardMaterial({ color: 0x2a2015, roughness: 0.7 });
    const nailMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.2 });

    const mirrorW = 0.6, mirrorH = 0.9;
    const frameThickness = 0.06;

    // Wooden frame around the mirror
    const mirrorFrame = new THREE.Mesh(new THREE.BoxGeometry(mirrorW + 0.1, mirrorH + 0.1, frameThickness), frameDarkMat);
    mirrorGroup.add(mirrorFrame);

    // Real-time reflection using THREE.Reflector
    const mirrorGeo = new THREE.PlaneGeometry(mirrorW, mirrorH);
    const mirrorReflector = new THREE.Reflector(mirrorGeo, {
        clipBias: 0.003,
        textureWidth: 512,
        textureHeight: 512,
        color: 0x777777,
        recursion: 1
    });
    mirrorReflector.position.set(0, 0, 0.031); // Slightly in front of frame to avoid z-fighting
    mirrorGroup.add(mirrorReflector);

    // Glass tint overlay for "thick glass" look
    const glassOverlay = new THREE.Mesh(
        new THREE.BoxGeometry(mirrorW, mirrorH, 0.01),
        new THREE.MeshPhysicalMaterial({
            color: 0x8899aa,
            metalness: 0.1,
            roughness: 0.1,
            transmission: 0.6,
            transparent: true,
            opacity: 0.2
        })
    );
    glassOverlay.position.set(0, 0, 0.036);
    mirrorGroup.add(glassOverlay);

    // Logical "nails" holding it to the wall
    [[-0.25, 0.42], [0.25, 0.42]].forEach(pos => {
        const nail = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.04, 8), nailMat);
        nail.rotation.x = Math.PI / 2;
        nail.position.set(pos[0], pos[1], -0.02);
        mirrorGroup.add(nail);
    });

    mirrorMesh = glassOverlay; // For interaction raycasting

    mirrorInteractMesh = new THREE.Mesh(
        new THREE.BoxGeometry(mirrorW + 0.2, mirrorH + 0.2, 0.2),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
    );
    mirrorGroup.add(mirrorInteractMesh);

    // Position on the left wall at player head height
    // Offset X by 0.11 to place it on the wall surface (wall center is -ROOM.w/2 + 0.04, thickness 0.08, so face is at +0.08 from origin, mirror back is at -0.03 local)
    mirrorGroup.position.set(-ROOM.w / 2 + 0.11, playerHeight, 1.95);
    mirrorGroup.rotation.y = Math.PI / 2;
    mirrorGroup.userData.canShift = false;
    scene.add(mirrorGroup);
    furnitureObjects.push(mirrorGroup);
    // No collision box needed as it's on the wall now.

    // Rug under bed area
    const rug = new THREE.Mesh(
        new THREE.PlaneGeometry(3, 2),
        new THREE.MeshStandardMaterial({
            color: 0x3a2820,
            roughness: 0.95,
            map: createCanvasTexture(128, 128, (ctx, w, h) => {
                ctx.fillStyle = '#3a2820';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#4a3830';
                ctx.lineWidth = 2;
                for (let i = 10; i < w; i += 20) {
                    for (let j = 10; j < h; j += 20) {
                        ctx.strokeRect(i - 5, j - 5, 10, 10);
                    }
                }
            })
        })
    );
    rug.rotation.x = -Math.PI / 2;
    rug.position.set(0, 0.005, -ROOM.d / 2 + 2.5);
    scene.add(rug);

    // Picture frame on back wall
    const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a2015 });
    const frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.03), frameMat);
    frame.position.set(2, 2, -ROOM.d / 2 + 0.02);
    scene.add(frame);

    const picTex = createCanvasTexture(128, 96, (ctx, w, h) => {
        ctx.fillStyle = '#1a1510';
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#2a2520';
        ctx.beginPath();
        ctx.arc(w/2, h/2 - 10, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(w/2 - 12, h/2 + 5, 24, 25);
    });
    const pic = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.5), new THREE.MeshStandardMaterial({ map: picTex }));
    pic.position.set(2, 2, -ROOM.d / 2 + 0.04);
    scene.add(pic);

    furnitureObjects.forEach(obj => {
        if (!obj.userData.basePos) obj.userData.basePos = obj.position.clone();
    });
}

function buildDoor() {
    const doorFrame = new THREE.Group();
    const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a2015, roughness: 0.6 });

    const top = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.08, 0.15), frameMat);
    top.position.set(-1, 2.54, ROOM.d / 2 - 0.05);
    doorFrame.add(top);

    const left = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.5, 0.15), frameMat);
    left.position.set(-1.53, 1.25, ROOM.d / 2 - 0.05);
    doorFrame.add(left);

    const right = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2.5, 0.15), frameMat);
    right.position.set(-0.47, 1.25, ROOM.d / 2 - 0.05);
    doorFrame.add(right);

    scene.add(doorFrame);

    doorHingeGroup = new THREE.Group();
    doorHingeGroup.position.set(-1.5, 0, ROOM.d / 2 - 0.06);
    scene.add(doorHingeGroup);

    doorMesh = new THREE.Mesh(
        new THREE.BoxGeometry(1, 2.5, 0.06),
        new THREE.MeshStandardMaterial({
            map: createCanvasTexture(128, 256, (ctx, w, h) => {
                ctx.fillStyle = '#35281c';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#2a1f15';
                ctx.lineWidth = 3;
                ctx.strokeRect(15, 15, w - 30, h * 0.35);
                ctx.strokeRect(15, h * 0.45, w - 30, h * 0.5);
            }),
            roughness: 0.7
        })
    );
    doorMesh.position.set(0.5, 1.25, 0);
    doorMesh.castShadow = true;
    doorHingeGroup.add(doorMesh);

    const doorHandleMat = new THREE.MeshStandardMaterial({ color: 0x887755, metalness: 0.8, roughness: 0.2 });
    
    const knobBase = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.02, 12), doorHandleMat);
    knobBase.rotation.x = Math.PI / 2;
    knobBase.position.set(0.88, 1.1, 0.035);
    doorHingeGroup.add(knobBase);

    const doorknob = new THREE.Mesh(
        new THREE.SphereGeometry(0.035, 16, 16),
        doorHandleMat
    );
    doorknob.position.set(0.88, 1.1, 0.06);
    doorHingeGroup.add(doorknob);

    const doorknobBack = new THREE.Mesh(
        new THREE.SphereGeometry(0.035, 16, 16),
        doorHandleMat
    );
    doorknobBack.position.set(0.88, 1.1, -0.06);
    doorHingeGroup.add(doorknobBack);

    // Keyhole plate
    const plate = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.15, 0.005), doorHandleMat);
    plate.position.set(0.88, 1.05, 0.031);
    doorHingeGroup.add(plate);

    // Wall light switch on the front wall, right side of the door.
    const switchPlate = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.18, 0.014),
        new THREE.MeshStandardMaterial({ color: 0xd8d8d8, roughness: 0.5, metalness: 0.05 })
    );
    switchPlate.position.set(-0.28, 1.32, ROOM.d / 2 - 0.02);
    scene.add(switchPlate);

    houseLightSwitchLever = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.08, 0.015),
        new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.45, metalness: 0.25 })
    );
    houseLightSwitchLever.position.set(-0.28, 1.32, ROOM.d / 2 - 0.012);
    houseLightSwitchLever.rotation.x = -0.45;
    scene.add(houseLightSwitchLever);

    houseLightSwitchMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.24, 0.12),
        new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
    );
    houseLightSwitchMesh.position.set(-0.28, 1.32, ROOM.d / 2 - 0.05);
    scene.add(houseLightSwitchMesh);
}

function windowSkyTexture(isMorning) {
    return createCanvasTexture(1024, 512, (ctx, w, h) => {
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        if (isMorning) {
            grad.addColorStop(0, '#b9dcff');
            grad.addColorStop(0.55, '#d9ecff');
            grad.addColorStop(1, '#e8f4ff');
        } else {
            grad.addColorStop(0, '#0a1020');
            grad.addColorStop(0.55, '#16233c');
            grad.addColorStop(1, '#20324f');
        }
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        if (!isMorning) {
            ctx.fillStyle = 'rgba(235,240,255,0.35)';
            for (let i = 0; i < 24; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h * 0.6;
                const r = 0.8 + Math.random() * 1.8;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

function windowFieldTexture(isMorning) {
    return createCanvasTexture(1024, 512, (ctx, w, h) => {
        const near = isMorning ? '#6aa95c' : '#345337';
        const mid = isMorning ? '#5a914f' : '#2d472f';
        const far = isMorning ? '#3f633c' : '#202f24';
        const grad = ctx.createLinearGradient(0, 0, w, 0);
        grad.addColorStop(0, near);
        grad.addColorStop(0.55, mid);
        grad.addColorStop(1, far);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        for (let i = 0; i < 1800; i++) {
            const x = Math.random() * w;
            const y = Math.random() * h;
            const alpha = isMorning ? 0.03 : 0.04;
            ctx.fillStyle = `rgba(20,40,18,${alpha})`;
            ctx.fillRect(x, y, 1.5 + Math.random() * 2.5, 1.5 + Math.random() * 2.5);
        }
    });
}

function setWindowExteriorMode(isMorning) {
    if (!windowMesh) return;

    if (isMorning) {
        windowMesh.material.color.setHex(0xc7ddf6);
        windowMesh.material.opacity = 0.16;
        if ('transmission' in windowMesh.material) windowMesh.material.transmission = 0.94;

        if (windowExteriorGroundMat) {
            windowExteriorGroundMat.map = windowFieldTexture(true);
            windowExteriorGroundMat.color.setHex(0xffffff);
            windowExteriorGroundMat.needsUpdate = true;
        }
        if (windowExteriorGrassMat) windowExteriorGrassMat.color.setHex(0x75af63);
        if (windowExteriorHillMat) windowExteriorHillMat.color.setHex(0x547e48);
        if (windowExteriorTreeLeafMat) windowExteriorTreeLeafMat.color.setHex(0x4f7d45);
        if (windowExteriorTreeTrunkMat) windowExteriorTreeTrunkMat.color.setHex(0x4f3725);
        if (windowExteriorSkyMat) {
            windowExteriorSkyMat.map = windowSkyTexture(true);
            windowExteriorSkyMat.color.setHex(0xffffff);
            windowExteriorSkyMat.needsUpdate = true;
        }

        if (windowExteriorAmbient) windowExteriorAmbient.intensity = 0.4;
        if (windowExteriorSun) {
            windowExteriorSun.intensity = 0.75;
            windowExteriorSun.color.setHex(0xffefc8);
        }
    } else {
        windowMesh.material.color.setHex(0x8da8c8);
        windowMesh.material.opacity = 0.24;
        if ('transmission' in windowMesh.material) windowMesh.material.transmission = 0.86;

        if (windowExteriorGroundMat) {
            windowExteriorGroundMat.map = windowFieldTexture(false);
            windowExteriorGroundMat.color.setHex(0xffffff);
            windowExteriorGroundMat.needsUpdate = true;
        }
        if (windowExteriorGrassMat) windowExteriorGrassMat.color.setHex(0x3b5737);
        if (windowExteriorHillMat) windowExteriorHillMat.color.setHex(0x354d37);
        if (windowExteriorTreeLeafMat) windowExteriorTreeLeafMat.color.setHex(0x273c2b);
        if (windowExteriorTreeTrunkMat) windowExteriorTreeTrunkMat.color.setHex(0x2f2219);
        if (windowExteriorSkyMat) {
            windowExteriorSkyMat.map = windowSkyTexture(false);
            windowExteriorSkyMat.color.setHex(0x90a2c8);
            windowExteriorSkyMat.needsUpdate = true;
        }

        if (windowExteriorAmbient) windowExteriorAmbient.intensity = 0.08;
        if (windowExteriorSun) {
            windowExteriorSun.intensity = 0.12;
            windowExteriorSun.color.setHex(0x8da6cc);
        }
    }
    windowMesh.material.needsUpdate = true;
}

function buildWindow() {
    // Window frame
    const frameMat = new THREE.MeshStandardMaterial({ color: 0x3a3025, roughness: 0.6 });
    const wGroup = new THREE.Group();

    const wTop = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 2.4), frameMat);
    wTop.position.set(0, 0.85, 0);
    wGroup.add(wTop);

    const wBottom = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 2.4), frameMat);
    wBottom.position.set(0, -0.85, 0);
    wGroup.add(wBottom);

    const wLeft = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.7, 0.06), frameMat);
    wLeft.position.set(0, 0, -1.17);
    wGroup.add(wLeft);

    const wRight = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.7, 0.06), frameMat);
    wRight.position.set(0, 0, 1.17);
    wGroup.add(wRight);

    const wMid = new THREE.Mesh(new THREE.BoxGeometry(0.04, 1.7, 0.04), frameMat);
    wMid.position.set(0, 0, 0);
    wGroup.add(wMid);

    const wMidH = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 2.4), frameMat);
    wMidH.position.set(0, 0, 0);
    wGroup.add(wMidH);

    wGroup.position.set(ROOM.w / 2 - 0.02, 1.65, 0);
    wGroup.rotation.y = 0;
    scene.add(wGroup);

    // Glass: clear, slightly tinted, real-window feel.
    windowMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2.3, 1.64),
        new THREE.MeshPhysicalMaterial({
            color: 0x8da8c8,
            transparent: true,
            opacity: 0.24,
            roughness: 0.08,
            metalness: 0,
            transmission: 0.86,
            clearcoat: 1,
            clearcoatRoughness: 0.08
        })
    );
    windowMesh.material.depthWrite = false;
    windowMesh.position.set(ROOM.w / 2 - 0.01, 1.65, 0);
    windowMesh.rotation.y = -Math.PI / 2;
    scene.add(windowMesh);

    // 3D exterior field outside the window.
    windowExteriorGroup = new THREE.Group();
    windowExteriorGroup.position.set(ROOM.w / 2 + 0.35, 0, 0);
    scene.add(windowExteriorGroup);

    const terrainGeo = new THREE.PlaneGeometry(30, 44, 48, 44);
    const terrainPos = terrainGeo.attributes.position;
    const terrainW = 30;
    for (let i = 0; i < terrainPos.count; i++) {
        const x = terrainPos.getX(i);
        const y = terrainPos.getY(i);
        const distT = (x + terrainW * 0.5) / terrainW;
        const bump = Math.sin(x * 0.3) * 0.08 + Math.cos(y * 0.25) * 0.06 + (Math.random() - 0.5) * 0.035;
        const falloff = -Math.pow(distT, 1.6) * 0.28;
        terrainPos.setZ(i, bump + falloff);
    }
    terrainGeo.rotateX(-Math.PI / 2);
    terrainGeo.computeVertexNormals();

    windowExteriorGroundMat = new THREE.MeshStandardMaterial({
        map: windowFieldTexture(false),
        color: 0xffffff,
        roughness: 0.97,
        metalness: 0
    });
    const terrain = new THREE.Mesh(terrainGeo, windowExteriorGroundMat);
    terrain.position.set(15.2, -0.07, 0);
    terrain.receiveShadow = false;
    windowExteriorGroup.add(terrain);

    windowExteriorHillMat = new THREE.MeshStandardMaterial({ color: 0x354d37, roughness: 0.95, metalness: 0 });
    for (let i = 0; i < 12; i++) {
        const hill = new THREE.Mesh(
            new THREE.SphereGeometry(0.8 + Math.random() * 1.1, 10, 8),
            windowExteriorHillMat
        );
        hill.scale.set(1.6 + Math.random() * 1.4, 0.45 + Math.random() * 0.28, 1.4 + Math.random() * 1.2);
        hill.position.set(12 + Math.random() * 14, -0.28 + Math.random() * 0.12, (Math.random() - 0.5) * 20);
        windowExteriorGroup.add(hill);
    }

    windowExteriorGrassMat = new THREE.MeshStandardMaterial({ color: 0x3b5737, roughness: 1, metalness: 0 });
    const grassGeo = new THREE.ConeGeometry(0.055, 0.22, 5);
    for (let i = 0; i < 260; i++) {
        const tuft = new THREE.Mesh(grassGeo, windowExteriorGrassMat);
        tuft.position.set(0.8 + Math.random() * 20, 0.02, (Math.random() - 0.5) * 36);
        tuft.rotation.y = Math.random() * Math.PI * 2;
        tuft.scale.setScalar(0.85 + Math.random() * 1.5);
        windowExteriorGroup.add(tuft);
    }

    windowExteriorTreeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x2f2219, roughness: 0.95, metalness: 0 });
    windowExteriorTreeLeafMat = new THREE.MeshStandardMaterial({ color: 0x273c2b, roughness: 0.98, metalness: 0 });
    for (let i = 0; i < 58; i++) {
        const tree = new THREE.Group();
        const trunkH = 0.75 + Math.random() * 0.55;
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.06, trunkH, 6),
            windowExteriorTreeTrunkMat
        );
        trunk.position.y = trunkH * 0.5 - 0.02;
        tree.add(trunk);

        const crown1 = new THREE.Mesh(
            new THREE.ConeGeometry(0.28 + Math.random() * 0.12, 0.65 + Math.random() * 0.2, 7),
            windowExteriorTreeLeafMat
        );
        crown1.position.y = trunkH + 0.26;
        tree.add(crown1);

        const crown2 = new THREE.Mesh(
            new THREE.ConeGeometry(0.2 + Math.random() * 0.1, 0.5 + Math.random() * 0.2, 7),
            windowExteriorTreeLeafMat
        );
        crown2.position.y = trunkH + 0.58;
        tree.add(crown2);

        tree.position.set(24 + Math.random() * 5, 0, -20 + i * (40 / 57) + (Math.random() - 0.5) * 0.55);
        tree.rotation.y = Math.random() * Math.PI * 2;
        windowExteriorGroup.add(tree);
    }

    windowExteriorSkyMat = new THREE.MeshBasicMaterial({
        map: windowSkyTexture(false),
        color: 0x90a2c8,
        side: THREE.BackSide
    });
    const skyDome = new THREE.Mesh(new THREE.SphereGeometry(34, 32, 20), windowExteriorSkyMat);
    skyDome.position.set(16, 10.5, 0);
    windowExteriorGroup.add(skyDome);

    windowExteriorAmbient = new THREE.AmbientLight(0x4d6688, 0.08);
    windowExteriorGroup.add(windowExteriorAmbient);

    windowExteriorSun = new THREE.DirectionalLight(0x8da6cc, 0.12);
    windowExteriorSun.position.set(5, 6, -2);
    windowExteriorSun.target.position.set(9, 0, 0);
    windowExteriorGroup.add(windowExteriorSun);
    windowExteriorGroup.add(windowExteriorSun.target);

    setWindowExteriorMode(false);
}


function buildShadowFigure() {
    const figGroup = new THREE.Group();
    const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), mat.clone());
    head.position.y = 1.7;
    figGroup.add(head);

    const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.2), mat.clone());
    body.position.y = 1.1;
    figGroup.add(body);

    const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.08), mat.clone());
    lArm.position.set(-0.28, 1.1, 0);
    figGroup.add(lArm);

    const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.08), mat.clone());
    rArm.position.set(0.28, 1.1, 0);
    figGroup.add(rArm);

    figGroup.position.set(-3, 0, -2);
    figGroup.visible = false;
    shadowFigure = figGroup;
    scene.add(shadowFigure);
}

function buildTV() {
    const tvGroup = new THREE.Group();
    const tvBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.5, 0.08),
        new THREE.MeshStandardMaterial({ color: 0x111111 })
    );
    tvGroup.add(tvBody);

    const tvScreen = new THREE.Mesh(
        new THREE.PlaneGeometry(0.7, 0.4),
        new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    tvScreen.position.z = 0.041;
    tvGroup.add(tvScreen);

    tvMesh = tvScreen;
    tvGroup.position.set(-2.2, 1.8, -ROOM.d / 2 + 0.06);
    scene.add(tvGroup);
}

function buildLighting() {
    ambientLight = new THREE.AmbientLight(0x151015, 0.3);
    scene.add(ambientLight);

    const hemiLight = new THREE.HemisphereLight(0x334466, 0x1a1410, 0.2);
    scene.add(hemiLight);

    // Ceiling light
    ceilingLight = new THREE.PointLight(0xffeedd, 0.4, 10, 2);
    ceilingLight.position.set(0, ROOM.h - 0.1, 0);
    ceilingLight.castShadow = true;
    ceilingLight.shadow.mapSize.width = 1024;
    ceilingLight.shadow.mapSize.height = 1024;
    ceilingLight.shadow.bias = -0.00025;
    ceilingLight.shadow.radius = 2;
    scene.add(ceilingLight);

    const bulb = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffeecc })
    );
    bulb.position.copy(ceilingLight.position);
    scene.add(bulb);

    // Lamp light
    lampLight = new THREE.PointLight(0xffcc88, 0.5, 5, 2);
    lampLight.position.set(-1.75, 1.1, -ROOM.d / 2 + 0.25);
    lampLight.castShadow = true;
    lampLight.shadow.mapSize.width = 1024;
    lampLight.shadow.mapSize.height = 1024;
    lampLight.shadow.bias = -0.0002;
    lampLight.shadow.radius = 2;
    scene.add(lampLight);

    // Faint moonlight from window
    moonLight = new THREE.DirectionalLight(0x334466, 0.08);
    moonLight.position.set(ROOM.w / 2 + 2, 3, 0);
    moonLight.target.position.set(0, 0, 0);
    scene.add(moonLight);
    scene.add(moonLight.target);

    morningSunLight = new THREE.DirectionalLight(0xfff2c7, 0);
    morningSunLight.position.set(ROOM.w / 2 + 3, 3.2, 0.5);
    morningSunLight.target.position.set(0, 0.5, 0);
    scene.add(morningSunLight);
    scene.add(morningSunLight.target);
}

function buildFlashlight() {
    // Rebuild per game mode so normal uses flashlight and nightmare uses lantern.
    if (flashlightMesh && flashlightMesh.parent) flashlightMesh.parent.remove(flashlightMesh);
    if (flashlightLight && flashlightLight.parent) flashlightLight.parent.remove(flashlightLight);
    if (flashlightFillLight && flashlightFillLight.parent) flashlightFillLight.parent.remove(flashlightFillLight);
    if (flashlightHintLight && flashlightHintLight.parent) flashlightHintLight.parent.remove(flashlightHintLight);
    if (flashlightTarget && flashlightTarget.parent) flashlightTarget.parent.remove(flashlightTarget);
    flashlightTarget = null;

    const group = new THREE.Group();

    if (nightmareActive) {
        // --- LANTERN (NIGHTMARE MODE) ---
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.4 });
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.05, 16), baseMat);
        base.position.y = 0.025;
        group.add(base);

        const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xffeedd, transmission: 0.8, roughness: 0.1, metalness: 0.1, clearcoat: 1 });
        const glass = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.12, 16), glassMat);
        glass.position.y = 0.11;
        group.add(glass);

        const wickMat = new THREE.MeshBasicMaterial({ color: 0xffaa44 });
        const wick = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.04, 8), wickMat);
        wick.position.y = 0.1;
        group.add(wick);

        const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.065, 0.04, 16), baseMat);
        cap.position.y = 0.19;
        group.add(cap);
        
        const capTop = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.04, 0.03, 16), baseMat);
        capTop.position.y = 0.225;
        group.add(capTop);

        const handleMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.5 });
        const handle = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.005, 8, 16, Math.PI), handleMat);
        handle.position.y = 0.23;
        group.add(handle);

        for (let i = 0; i < 4; i++) {
            const guard = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.13, 4), handleMat);
            guard.position.set(Math.cos(i * Math.PI / 2) * 0.055, 0.11, Math.sin(i * Math.PI / 2) * 0.055);
            group.add(guard);
        }
    } else {
        // --- FLASHLIGHT (NORMAL MODE) ---
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.75, roughness: 0.28 });
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.032, 0.042, 0.22, 20), bodyMat);
        body.rotation.z = Math.PI / 2;
        group.add(body);

        const grip = new THREE.Mesh(
            new THREE.CylinderGeometry(0.038, 0.038, 0.1, 20),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.3, roughness: 0.7 })
        );
        grip.rotation.z = Math.PI / 2;
        grip.position.x = -0.02;
        group.add(grip);

        const headMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.8, roughness: 0.2 });
        const head = new THREE.Mesh(new THREE.CylinderGeometry(0.048, 0.052, 0.05, 20), headMat);
        head.rotation.z = Math.PI / 2;
        head.position.x = 0.13;
        group.add(head);

        const lens = new THREE.Mesh(
            new THREE.CylinderGeometry(0.042, 0.042, 0.005, 20),
            new THREE.MeshPhysicalMaterial({ color: 0xffeedd, transmission: 0.6, roughness: 0.1, metalness: 0, clearcoat: 1 })
        );
        lens.rotation.z = Math.PI / 2;
        lens.position.x = 0.155;
        group.add(lens);

        const bezel = new THREE.Mesh(
            new THREE.TorusGeometry(0.048, 0.004, 8, 20),
            new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.15 })
        );
        bezel.rotation.y = Math.PI / 2;
        bezel.position.x = 0.155;
        group.add(bezel);

        const button = new THREE.Mesh(
            new THREE.CylinderGeometry(0.008, 0.008, 0.006, 8),
            new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.4 })
        );
        button.position.set(0.04, 0.038, 0);
        group.add(button);
    }

    flashlightMesh = group;
    flashlightMesh.position.set(2.35, 0.82, -ROOM.d / 2 + 0.52);
    if (!nightmareActive) flashlightMesh.rotation.y = -0.3;
    scene.add(flashlightMesh);

    const q = QUALITY_PRESETS[gameSettings.quality] || QUALITY_PRESETS.high;
    if (nightmareActive) {
        // Lantern: short-range omni light around player.
        flashlightLight = new THREE.PointLight(0xffaa55, 0, 6.5, 2.2);
    } else {
        flashlightLight = new THREE.SpotLight(0xffeedd, 0, 22, 0.48, 0.55, 1.4);
        flashlightTarget = new THREE.Object3D();
        scene.add(flashlightTarget);
        flashlightLight.target = flashlightTarget;
    }

    flashlightLight.castShadow = q.flashlightShadow;
    if (q.flashlightShadow) {
        flashlightLight.shadow.mapSize.set(q.shadowRes, q.shadowRes);
        flashlightLight.shadow.bias = -0.002;
        if (!nightmareActive) {
            flashlightLight.shadow.radius = 2;
            flashlightLight.shadow.camera.near = 0.1;
            flashlightLight.shadow.camera.far = 16;
        }
    }
    
    scene.add(flashlightLight);

    flashlightFillLight = new THREE.PointLight(
        nightmareActive ? 0xff9944 : 0xffeedd,
        0,
        nightmareActive ? 3.6 : 5,
        nightmareActive ? 2.3 : 1.6
    );
    scene.add(flashlightFillLight);

    flashlightHintLight = new THREE.PointLight(0xfff0b0, 0, 4.5, 1.3);
    flashlightHintLight.position.copy(flashlightMesh.position).add(new THREE.Vector3(0, 0.08, 0));
    scene.add(flashlightHintLight);
}

function applyBlackout() {
    blackoutTriggered = true;
    houseLightsOn = false;
    lampOn = false;
    playGlassBreak();
    ceilingLight.intensity = 0;
    lampLight.intensity = 0;
    if (lampBulbMat) lampBulbMat.emissiveIntensity = 0;
    if (houseLightSwitchLever) houseLightSwitchLever.rotation.z = 0.45;
    if (ambientLight) ambientLight.intensity = 0;
    if (moonLight) moonLight.intensity = 0;
    renderer.toneMappingExposure = 0.08;
    scene.fog = new THREE.Fog(0x000000, 1, 6);
    scene.background = new THREE.Color(0x000000);
    tvOn = false;
    if (tvMesh) tvMesh.material.color.setHex(0x000000);
    writings.forEach(w => { w.material.opacity = 0; });
    document.getElementById('blood-overlay').style.opacity = '0';
    document.getElementById('static-overlay').style.opacity = '0';
    showDialogue("...glass just shattered. It's pitch black.", 2600);
    showThought("there's a faint light on the desk to the right...");
    if (nightmareActive) {
        flashlightBattery = Math.max(0.95, flashlightBattery);
        flashlightBatteryNotifiedDead = false;
        flashlightBatteryDrainDuration = Math.max(12, (phaseTimers[9] - phaseTimers[6]) * 0.5);
        nightmareDarknessTimer = 0;
        setNightmareBatteryVisibility(true);
        showThought("nightmare mode: the lantern fluid won't last long.");
    } else {
        setNightmareBatteryVisibility(false);
    }
    updateBatteryHud();
}

function showDialogue(text, duration = 4000, source = 'general') {
    if (!gameSettings.subtitles) return;
    if (dialogueSourceLock && source !== dialogueSourceLock) return;
    const el = DOM.dialogue;
    if (!el) return;
    clearTimeout(el._hideTimer);
    clearTimeout(el._displayNoneTimer);
    el.textContent = text;
    el.style.display = 'block';
    el.style.opacity = '1';
    el.style.animation = 'none';
    el.offsetHeight;
    el.style.animation = 'dialogueFadeIn 0.3s ease';
    el._hideTimer = setTimeout(() => {
        el.style.opacity = '0';
        el._displayNoneTimer = setTimeout(() => { el.style.display = 'none'; }, 500);
    }, duration);
}

function showThought(text, duration = 3000, source = 'general') {
    if (!gameSettings.subtitles) return;
    if (dialogueSourceLock && source !== dialogueSourceLock) return;
    const el = DOM.thought;
    if (!el) return;
    clearTimeout(el._hideTimer);
    clearTimeout(el._displayNoneTimer);
    el.textContent = text;
    el.style.transition = 'opacity 0.5s';
    el.style.display = 'block';
    el.style.opacity = '1';
    el._hideTimer = setTimeout(() => {
        el.style.transition = 'opacity 2s';
        el.style.opacity = '0';
        el._displayNoneTimer = setTimeout(() => {
            el.style.display = 'none';
            el.style.transition = 'opacity 0.5s';
        }, 2000);
    }, duration);
}

function triggerKnock(suppressResponse = false) {
    if (sleepEndingActive) return;
    playKnock();
    if (doorMesh) {
        const origZ = doorMesh.position.z;
        let knockAnim = 0;
        const knockInterval = setInterval(() => {
            knockAnim++;
            doorMesh.position.z = origZ + Math.sin(knockAnim * 0.8) * 0.008 * Math.max(0, 1 - knockAnim / 20);
            if (knockAnim > 20) {
                doorMesh.position.z = origZ;
                clearInterval(knockInterval);
            }
        }, 30);
    }

    const responses = [
        "I'm fine... nobody's there.",
        "I'm fine, nobody's there...",
        "It's nothing. I'm fine. Nobody's there.",
        "I'm fine... it's just the wind... nobody's there.",
        "Nobody's there. I'm fine. I'm fine.",
        "I'm fine... there's nobody there... I'm fine...",
    ];
    if (!suppressResponse) {
        setTimeout(() => {
            showDialogue(responses[Math.floor(Math.random() * responses.length)], 3500);
        }, 1200);
    }
}

function setFigureOpacity(opacity) {
}

function setShadowFigureOpacity(opacity) {
    if (!shadowFigure) return;
    shadowFigure.visible = opacity > 0;
    shadowFigure.children.forEach(child => {
        if (child.material) child.material.opacity = opacity;
    });
}

function flickerLights(intensity = 1, duration = 2000) {
    if (sleepEndingActive) return;
    lightFlickering = true;
    const origCeiling = ceilingLight.intensity;
    const origLamp = lampLight.intensity;

    if (shouldReduceFlashingEffects()) {
        const gentleFactor = Math.max(0.35, Math.min(1, 0.75 * intensity));
        ceilingLight.intensity = origCeiling * gentleFactor;
        lampLight.intensity = origLamp * gentleFactor;
        setTimeout(() => {
            ceilingLight.intensity = origCeiling;
            lampLight.intensity = origLamp;
            lightFlickering = false;
        }, Math.min(950, duration));
        return;
    }

    const startTime = Date.now();

    const flick = setInterval(() => {
        const elapsed = Date.now() - startTime;
        if (elapsed > duration) {
            ceilingLight.intensity = origCeiling;
            lampLight.intensity = origLamp;
            lightFlickering = false;
            clearInterval(flick);
            return;
        }
        const r = Math.random();
        ceilingLight.intensity = r < 0.3 ? 0 : origCeiling * (0.5 + Math.random() * 0.5) * intensity;
        lampLight.intensity = r < 0.4 ? 0 : origLamp * (0.3 + Math.random() * 0.7) * intensity;
    }, 50);
}

function addWallWriting(text, x, y, z, rotY = 0) {
    const tex = createCanvasTexture(512, 128, (ctx, w, h) => {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(120, 10, 10, 0.7)';
        ctx.font = `${28 + Math.random() * 20}px "Courier New"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const chars = text.split('');
        let xPos = w / 2 - (chars.length * 12) / 2;
        chars.forEach(c => {
            ctx.save();
            ctx.translate(xPos, h / 2 + (Math.random() - 0.5) * 15);
            ctx.rotate((Math.random() - 0.5) * 0.15);
            ctx.fillText(c, 0, 0);
            ctx.restore();
            xPos += 12 + Math.random() * 8;
        });
    });
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0, depthWrite: false });
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.4), mat);
    mesh.position.set(x, y, z);
    mesh.rotation.y = rotY;
    scene.add(mesh);
    writings.push(mesh);
    return mesh;
}

let phaseExecuted = {};

function updatePhases(dt) {
    if (sleepEndingActive || closetEndingActive || phoneEndingActive) return;
    gameTime += dt;

    // Phase 1: First knock (10s)
    if (gameTime > phaseTimers[1] && !phaseExecuted[1]) {
        phaseExecuted[1] = true;
        phase = 1;
        triggerKnock();
        playDrone(50, 5);
    }

    // Phase 2: Figure appears briefly, more knocks (30s)
    if (gameTime > phaseTimers[2] && !phaseExecuted[2]) {
        phaseExecuted[2] = true;
        phase = 2;
        setFigureOpacity(0.12);
        setTimeout(() => setFigureOpacity(0), 2000);
        setTimeout(() => triggerKnock(), 1000);
        showThought("did something move...?");
    }

    // Phase 3: Lights flicker, figure more visible (55s)
    if (gameTime > phaseTimers[3] && !phaseExecuted[3]) {
        phaseExecuted[3] = true;
        phase = 3;
        flickerLights(1, 3000);
        playCreak();
        setTimeout(() => {
            setFigureOpacity(0.18);
            playDrone(40, 6);
        }, 3000);
        setTimeout(() => showThought("the lights... it's just old wiring..."), 1500);
    }

    // Phase 4: Knocking intensifies, writing appears (80s)
    if (gameTime > phaseTimers[4] && !phaseExecuted[4]) {
        phaseExecuted[4] = true;
        phase = 4;
        triggerKnock();
        setTimeout(() => triggerKnock(), 3000);
        setTimeout(() => triggerKnock(), 5500);
        addWallWriting("LET ME IN", 1, 2.2, -ROOM.d / 2 + 0.03);
        setTimeout(() => {
            writings.forEach(w => { w.material.opacity = 0.7; });
            playWhisper();
        }, 6000);
        setTimeout(() => showThought("why won't it stop..."), 4000);
    }

    // Phase 5: TV turns on with static, shadow figure appears (110s)
    if (gameTime > phaseTimers[5] && !phaseExecuted[5]) {
        phaseExecuted[5] = true;
        phase = 5;
        tvOn = true;
        if (tvMesh) tvMesh.material.color.setHex(0x222222);
        flickerLights(1.5, 4000);
        playDrone(35, 8);
        setTimeout(() => {
            setFigureOpacity(0.24);
            triggerKnock();
        }, 2000);
        addWallWriting("YOU'RE NOT ALONE", -1, 1.5, -ROOM.d / 2 + 0.03);
        setTimeout(() => {
            writings.forEach(w => { w.material.opacity = 0.8; });
        }, 3000);
        showThought("i need to calm down... this isn't real...");
    }

    // Phase 6: Room gets darker, heartbeat, objects shift (140s)
    if (gameTime > phaseTimers[6] && !phaseExecuted[6]) {
        phaseExecuted[6] = true;
        phase = 6;
        applyBlackout();
        setFigureOpacity(0.28);
        playHeartbeat();
        setInterval(() => { if (phase >= 6 && !endingTriggered) playHeartbeat(); }, 3000);
        addWallWriting("BEHIND YOU", 0, 2, ROOM.d / 2 - 0.05, Math.PI);
        setTimeout(() => { writings.forEach(w => { w.material.opacity = 0.9; }); }, 1000);
        triggerKnock();
        showDialogue("I'M FINE! NOBODY'S THERE! I'M FINE!", 4000);

        showDialogue(
            nightmareActive
                ? "I'm fine... nobody's there... just find the lantern."
                : "I'm fine... nobody's there... just find the flashlight.",
            3500
        );
    }

    // Phase 7: Heavy breathing, constant knocking, figure presses against window (170s)
    if (gameTime > phaseTimers[7] && !phaseExecuted[7]) {
        phaseExecuted[7] = true;
        phase = 7;
        if (!blackoutTriggered) {
            document.getElementById('blood-overlay').style.opacity = shouldReduceFlashingEffects() ? '0.08' : '0.3';
            document.getElementById('static-overlay').style.opacity = shouldReduceFlashingEffects() ? '0.04' : '0.15';
        }
        flickerLights(2, 5000);
        playDrone(30, 10);
        playWhisper();

        // Rapid knocking
        for (let i = 0; i < 6; i++) {
            setTimeout(() => triggerKnock(), i * 2000);
        }

        addWallWriting("IT'S INSIDE", -ROOM.w / 2 + 0.03, 1.8, -1, Math.PI / 2);
        if (!blackoutTriggered) {
            setTimeout(() => { writings.forEach(w => { w.material.opacity = 1; }); }, 2000);
        }

        showThought("no no no no no...");
    }

    // Phase 8: Shadow figure in room (200s)
    if (gameTime > phaseTimers[8] && !phaseExecuted[8]) {
        phaseExecuted[8] = true;
        phase = 8;
        figureInRoom = true;

        flickerLights(2, 2000);
        
        if (nightmareActive) {
            // Flash screen red 4 times before spawning
            const redFlash = document.getElementById('red-flash-overlay');
            if (redFlash) {
                const reducedFlashing = shouldReduceFlashingEffects();
                const totalFlashes = reducedFlashing ? 2 : 4;
                const flashIntervalMs = reducedFlashing ? 1200 : 1000;
                const flashVisibleMs = reducedFlashing ? 420 : 300;
                let flashes = 0;
                playHeartbeat();
                const flashInterval = setInterval(() => {
                    flashes++;
                    redFlash.style.opacity = `${safeFlashOpacity(1)}`;
                    playTone(180, 0.1, 'sawtooth', 0.05);
                    setTimeout(() => { redFlash.style.opacity = '0'; }, flashVisibleMs);
                    
                    if (flashes >= totalFlashes) {
                        clearInterval(flashInterval);
                        setTimeout(() => {
                            shadowFigure.visible = true;
                            shadowFigure.position.set(0, 0, ROOM.d / 2 - 1);
                            setShadowFigureOpacity(0.9);
                            playDrone(25, 12);
                            playWhisper();
                        }, 500);
                    }
                }, flashIntervalMs);
            }
        } else {
            setTimeout(() => {
                if (!blackoutTriggered) {
                    ceilingLight.intensity = houseLightsOn ? 0.15 : 0;
                    lampLight.intensity = lampOn ? 0.15 : 0;
                    if (lampBulbMat) lampBulbMat.emissiveIntensity = lampOn ? 0.8 : 0;
                    renderer.toneMappingExposure = 0.2;
                }
                shadowFigure.visible = true;
                shadowFigure.position.set(0, 0, ROOM.d / 2 - 1);
                setShadowFigureOpacity(0.9);
                playDrone(25, 12);
                playWhisper();
            }, 2000);
        }

        showDialogue("I'm fine... I'm fine... nobody's there... nobody's...", 5000);
        if (!blackoutTriggered) {
            document.getElementById('blood-overlay').style.opacity = shouldReduceFlashingEffects() ? '0.12' : '0.5';
            document.getElementById('static-overlay').style.opacity = shouldReduceFlashingEffects() ? '0.06' : '0.3';
        }

        addWallWriting("WAKE UP", 0, 2.5, -ROOM.d / 2 + 0.03);
        addWallWriting("YOU CAN'T LEAVE", ROOM.w / 2 - 0.03, 2, 1, -Math.PI / 2);
        if (!blackoutTriggered) {
            setTimeout(() => { writings.forEach(w => { w.material.opacity = 1; }); }, 1000);
        }
    }

    // Phase 9: Ending (225s)
    if (gameTime > phaseTimers[9] && !phaseExecuted[9]) {
        phaseExecuted[9] = true;
        phase = 9;
        if (nightmareActive) {
            triggerNightmareEnding();
        } else {
            triggerEnding();
        }
    }

    // Ambient events between phases
    if (phase >= 2) {
        nextKnockTime -= dt;
        if (nextKnockTime <= 0) {
            if (nightmareActive) {
                nextKnockTime = Math.max(1.3, 7 - phase * 0.55) + Math.random() * 2.3;
                triggerKnock(Math.random() < 0.55);
                if (Math.random() < 0.28) {
                    setTimeout(() => triggerKnock(true), 250 + Math.random() * 520);
                }
            } else {
                nextKnockTime = Math.max(5, 18 - phase * 2) + Math.random() * 8;
                triggerKnock();
            }
        }
    }

    if (phase >= 3 && Math.random() < 0.001) {
        playCreak();
    }

    if (phase >= 4 && Math.random() < 0.0005) {
        flickerLights(1, 500 + Math.random() * 1000);
    }

    if (phase >= 5 && Math.random() < (nightmareActive ? 0.0011 : 0.0003)) {
        if (nightmareActive && Math.random() < 0.65) {
            playEarWhisper();
        } else {
            playWhisper();
        }
    }

    // TV static
    if (tvOn && tvMesh) {
        const brightness = 0.1 + Math.random() * 0.15;
        tvMesh.material.color.setRGB(brightness, brightness, brightness * 0.95);
    }

    // Shadow figure slowly approaches in phase 8
    if (figureInRoom && shadowFigure && shadowFigure.visible && !endingTriggered) {
        const dir = new THREE.Vector3();
        dir.subVectors(camera.position, shadowFigure.position);
        dir.y = 0;
        const dist = dir.length();
        if (dist > 0.0001) dir.normalize();
        const speed = nightmareActive ? 0.0019 : 0.001;
        shadowFigure.position.x += dir.x * speed;
        shadowFigure.position.z += dir.z * speed;
        shadowFigure.lookAt(camera.position.x, 0, camera.position.z);
    }
}

function playJumpscareAudioOnly(callback) {
    const media = document.getElementById('jumpscare-video');
    if (!media) {
        if (callback) callback();
        return;
    }

    // Never show the video; only use its audio track.
    media.style.display = 'none';

    // Stop movement SFX so only jumpscare audio is heard.
    if (!walkingAudio.paused) walkingAudio.pause();
    if (!runningAudio.paused) runningAudio.pause();

    media.pause();
    media.currentTime = 0;
    media.onended = null;
    media.onended = () => {
        media.pause();
        media.currentTime = 0;
        if (callback) callback();
    };

    const playPromise = media.play();
    if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch((e) => {
            console.warn("Jumpscare audio failed to play:", e);
            // Fallback so the game cannot get stuck on black.
            setTimeout(() => {
                if (callback) callback();
            }, 900);
        });
    }
}

function triggerEnding() {
    if (endingTriggered) return;
    endingTriggered = true;
    sleepTransitionActive = true;
    if (ambientInterval) clearInterval(ambientInterval);
    setNightmareBatteryVisibility(false);
    updateBatteryHud();

    // Flash
    const flash = document.getElementById('flash');
    triggerScreenFlash(1, 100, 500);
    playScream();

    // Everything goes dark
    setTimeout(() => {
        ceilingLight.intensity = 0;
        lampLight.intensity = 0;
        renderer.toneMappingExposure = 0.05;
        tvOn = false;
        if (tvMesh) tvMesh.material.color.setHex(0x000000);
    }, 600);

    // Shadow figure right in front
    setTimeout(() => {
        shadowFigure.position.copy(camera.position);
        shadowFigure.position.z -= 0.5;
        shadowFigure.position.y = 0;
        setShadowFigureOpacity(1);
        playDrone(20, 5);
    }, 2000);

    // Final jumpscare audio-only and ending screen
    setTimeout(() => {
        const fade = document.getElementById('sleep-fade');
        fade.style.transition = 'opacity 0.25s ease';
        fade.style.opacity = '1';
        flash.style.opacity = '0';
        playJumpscareAudioOnly(() => {
            showEndingScreen("YOU WERE NEVER ALONE", "Thank you for playing", "neverAlone");
        });
    }, 3500);
}

let nightmareDeathPending = false;
function triggerNightmareDeath(title = "CONSUMED BY THE DARK", subtitle = "You stayed too long where the light couldn't reach.") {
    if (!nightmareActive || endingTriggered || nightmareDeathPending) return;
    nightmareDeathPending = true;

    // Flash screen red 4 times before the monster spawns and kills
    const redFlash = document.getElementById('red-flash-overlay');
    let flashes = 0;
    
    // Stop movement and interactions while dying
    sleepTransitionActive = true; 
    setNightmareBatteryVisibility(false);
    updateBatteryHud();
    if (ambientInterval) clearInterval(ambientInterval);

    if (redFlash) {
        const reducedFlashing = shouldReduceFlashingEffects();
        const totalFlashes = reducedFlashing ? 2 : 4;
        const flashIntervalMs = reducedFlashing ? 1100 : 800;
        const flashVisibleMs = reducedFlashing ? 420 : 250;
        const flashOpacity = safeFlashOpacity(1);
        const flashInterval = setInterval(() => {
            flashes++;
            redFlash.style.opacity = `${flashOpacity}`;
            playTone(140, 0.2, 'sawtooth', 0.05);
            setTimeout(() => { redFlash.style.opacity = '0'; }, flashVisibleMs);
            
            if (flashes >= totalFlashes) {
                clearInterval(flashInterval);
                // Spawn monster directly in front of player
                setTimeout(() => {
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyEuler(new THREE.Euler(0, yaw, 0, 'YXZ'));
                    
                    shadowFigure.position.copy(camera.position).add(forward.multiplyScalar(0.8));
                    shadowFigure.position.y = 0;
                    shadowFigure.visible = true;
                    setShadowFigureOpacity(1);
                    playDrone(20, 5);
                    
                    // Proceed to actual death after a brief moment of seeing the monster
                    setTimeout(() => {
                        endingTriggered = true;
                        
                        const fade = document.getElementById('sleep-fade');
                        fade.style.transition = 'opacity 0.2s linear';
                        fade.style.opacity = '1';

                        playScream();
                        playEarWhisper();
                        showThought("don't look back.");

                        setTimeout(() => {
                            playJumpscareAudioOnly(() => {
                                showEndingScreen(title, subtitle);
                            });
                        }, 250);
                    }, 600);
                }, 400);
            }
        }, flashIntervalMs);
    } else {
        // Fallback if overlay is missing
        endingTriggered = true;
        const fade = document.getElementById('sleep-fade');
        fade.style.transition = 'opacity 0.2s linear';
        fade.style.opacity = '1';
        playScream();
        playEarWhisper();
        setTimeout(() => {
            playJumpscareAudioOnly(() => {
                showEndingScreen(title, subtitle);
            });
        }, 250);
    }
}

function triggerWallEnding() {
    if (wallEndingTriggered || endingTriggered) return;
    wallEndingTriggered = true;
    wallEndingActive = true;
    sleepTransitionActive = true;
    if (ambientInterval) clearInterval(ambientInterval);
    setNightmareBatteryVisibility(false);
    updateBatteryHud();

    showDialogue("The walls... they're moving.", 3000);
    playDrone(30, 15);

    const redFlash = document.getElementById('red-flash-overlay');
    const startTime = Date.now();
    const duration = 12000;
    const originalRoomW = ROOM.w;
    const originalRoomD = ROOM.d;

    function animateWalls() {
        const elapsed = Date.now() - startTime;
        const t = Math.min(1, elapsed / duration);
        const ease = t * t;

        ROOM.w = originalRoomW * (1 - ease * 0.7);
        ROOM.d = originalRoomD * (1 - ease * 0.7);

        if (redFlash) {
            const pulse = Math.sin(elapsed * 0.008) * 0.3 + 0.3;
            redFlash.style.opacity = `${safeFlashOpacity(pulse * t)}`;
        }

        if (t < 0.3) {
            showThought("no... this can't be happening...");
        } else if (t < 0.6) {
            showDialogue("STOP! STOP MOVING!", 2000);
        } else if (t < 0.85) {
            showDialogue("I CAN'T BREATHE!", 2000);
        }

        if (t >= 1) {
            if (redFlash) redFlash.style.opacity = `${safeFlashOpacity(1)}`;
            playScream();
            playTone(80, 1.0, 'sawtooth', 0.08);

            setTimeout(() => {
                const fade = document.getElementById('sleep-fade');
                fade.style.transition = 'opacity 0.3s linear';
                fade.style.opacity = '1';

                setTimeout(() => {
                    endingTriggered = true;
                    ROOM.w = originalRoomW;
                    ROOM.d = originalRoomD;
                    if (redFlash) redFlash.style.opacity = '0';
                    showEndingScreen("THE WALLS ARE CLOSING IN", "The room swallowed you whole.", "wallsClosing");
                }, 800);
            }, 400);
            return;
        }

        requestAnimationFrame(animateWalls);
    }

    setTimeout(() => {
        playTone(60, 0.5, 'sawtooth', 0.06);
        playHeartbeat();
        animateWalls();
    }, 2000);

    setTimeout(() => playHeartbeat(), 4000);
    setTimeout(() => playHeartbeat(), 6000);
    setTimeout(() => playHeartbeat(), 8000);
    setTimeout(() => playHeartbeat(), 10000);
}

function triggerNightmareEnding() {
    if (endingTriggered) return;
    endingTriggered = true;
    sleepTransitionActive = true;
    if (ambientInterval) clearInterval(ambientInterval);
    setNightmareBatteryVisibility(false);

    const fade = document.getElementById('sleep-fade');
    showThought("The knocking finally stops.");
    playDrone(18, 10);

    setTimeout(() => {
        playUncannyPhoneVoiceLine("Thank you for opening it.");
        showDialogue("\"...thank you for opening it...\"", 3000);
    }, 1200);

    setTimeout(() => {
        triggerScreenFlash(1, 120, 250);
        playScream();
    }, 3000);

    setTimeout(() => {
        fade.style.transition = 'opacity 0.8s ease';
        fade.style.opacity = '1';
    }, 3900);

    setTimeout(() => {
        showEndingScreen("YOU LET IT OUT", "You stepped outside. It stepped in.", "nightmare");
    }, 5200);
}

function updateNightmareMode(dt) {
    if (!nightmareActive || !gameStarted || endingTriggered || sleepEndingActive || sleepTransitionActive || closetEndingActive || phoneEndingActive || wallEndingActive) {
        return;
    }

    nightmareWhisperTimer -= dt;
    if (phase >= 3 && nightmareWhisperTimer <= 0) {
        playEarWhisper();
        const whisperChance = phase >= 7 ? 0.4 : phase >= 5 ? 0.28 : 0.18;
        if (Math.random() < whisperChance) {
            const line = NIGHTMARE_WHISPERS[Math.floor(Math.random() * NIGHTMARE_WHISPERS.length)];
            playScaryVoiceLine(line);
            if (line === "The walls are closing in." && phase >= 6 && !wallEndingTriggered && !endingTriggered) {
                triggerWallEnding();
                return;
            }
        }
        nightmareWhisperTimer = (phase >= 7 ? 1.2 : 2) + Math.random() * (phase >= 7 ? 2.5 : 4);
    }

    nightmareKnockBurstTimer -= dt;
    if (phase >= 2 && nightmareKnockBurstTimer <= 0) {
        triggerKnock(true);
        if (Math.random() < 0.55) {
            setTimeout(() => triggerKnock(true), 220 + Math.random() * 450);
        }
        nightmareKnockBurstTimer = 1.5 + Math.random() * 3.2;
    }

    if (blackoutTriggered && phase >= 6 && flashlightHeld && flashlightOn && flashlightBattery > 0) {
        flashlightBattery = Math.max(0, flashlightBattery - dt / flashlightBatteryDrainDuration);
        if (flashlightBattery <= 0.001) {
            flashlightBattery = 0;
            if (!flashlightBatteryNotifiedDead) {
                flashlightOn = false;
                flashlightBatteryNotifiedDead = true;
                showDialogue(nightmareActive ? "The lantern is out of fluid. Find a lighter." : "The flashlight battery died. Find a battery.", 3000);
                playTone(140, 0.4, 'sawtooth', 0.03);
            }
        }
    }

    if (blackoutTriggered && phase >= 6) {
        const inDarkness = !flashlightHeld || !flashlightOn || flashlightBattery <= 0.01;
        nightmareDarknessTimer = inDarkness
            ? nightmareDarknessTimer + dt
            : Math.max(0, nightmareDarknessTimer - dt * 1.5);

        if (phase >= 7 && nightmareDarknessTimer > 17) {
            triggerNightmareDeath();
        }
    }

    if (phase >= 8 && phase < 9 && shadowFigure && shadowFigure.visible) {
        const dx = camera.position.x - shadowFigure.position.x;
        const dz = camera.position.z - shadowFigure.position.z;
        if (Math.hypot(dx, dz) < 0.65) {
            triggerNightmareDeath("CAUGHT", "You weren't the hunter.");
        }
    }

    updateBatteryHud();
}

function triggerSleepEndingStart() {
    if (nightmareActive) {
        showDialogue("You can't wake up yet.", 1700);
        return;
    }
    if (sleepEndingActive || endingTriggered) return;
    sleepTransitionActive = true;
    sleepEndingActive = true;
    doorUnlocked = true;
    phase = 0;

    if (ambientInterval) clearInterval(ambientInterval);

    const sleepFade = document.getElementById('sleep-fade');
    sleepFade.style.transition = 'opacity 2.1s ease';
    sleepFade.style.opacity = '1';
    playBedRustle();
    setTimeout(() => playBedRustle(), 700);

    setTimeout(() => {
    // Calm morning reset.
    setFigureOpacity(0);
    setShadowFigureOpacity(0);
    shadowFigure.visible = false;
    tvOn = false;
    if (tvMesh) tvMesh.material.color.setHex(0x000000);
    writings.forEach(w => { w.material.opacity = 0; });
    document.getElementById('blood-overlay').style.opacity = '0';
    document.getElementById('static-overlay').style.opacity = '0';
    blackoutTriggered = false;
    setNightmareBatteryVisibility(false);
    updateBatteryHud();

    scene.background = new THREE.Color(0xd9ecff);
    scene.fog = new THREE.Fog(0xd9ecff, 14, 32);
    renderer.toneMappingExposure = 1.18;
    if (ambientLight) ambientLight.intensity = 1.0;
    if (moonLight) moonLight.intensity = 0;
    if (morningSunLight) morningSunLight.intensity = 1.15;
    houseLightsOn = true;
    lampOn = true;
    ceilingLight.intensity = 1.05;
    lampLight.intensity = 0.28;
    if (lampBulbMat) lampBulbMat.emissiveIntensity = 1.4;
    if (houseLightSwitchLever) houseLightSwitchLever.rotation.z = -0.45;
    setWindowExteriorMode(true);

    playMorningBirds();
    sleepFade.style.transition = 'opacity 1.7s ease';
    sleepFade.style.opacity = '0';
    sleepTransitionActive = false;

    showDialogue("Morning... I slept through everything?", 3500);
    showThought("the door can open now.");
    }, 2400);
}

function triggerSleptThroughEnding() {
    if (endingTriggered) return;
    endingTriggered = true;
    showEndingScreen("SLEPT THROUGH IT ALL", "You woke up safe, never knowing what happened.", "sleptThrough");
}

function triggerClosetEnding() {
    if (nightmareActive) {
        showDialogue("No hiding this time.", 1700);
        return;
    }
    if (closetEndingActive || endingTriggered) return;
    closetEndingActive = true;
    sleepTransitionActive = true;
    setNightmareBatteryVisibility(false);
    updateBatteryHud();
    closetHoldSeconds = 0;
    if (ambientInterval) clearInterval(ambientInterval);
    showDialogue("Fine... I will open it.", 2200);
    playCreak();

    const sleepFade = document.getElementById('sleep-fade');
    setTimeout(() => {
        sleepFade.style.transition = 'opacity 1.4s ease';
        sleepFade.style.opacity = '1';
        showThought("You hide in the closet.");
    }, 1200);

    // 15s sequence: voice line at 13s, ending at 15s.
    setTimeout(() => {
        playScaryVoiceLine("I'm behind you");
        showDialogue("...I'm behind you...", 2600);
    }, 13000);

    setTimeout(() => {
        if (endingTriggered) return;
        endingTriggered = true;
        showEndingScreen("I'M BEHIND YOU", "Hiding didn't save you.", "closet");
    }, 15000);
}

function triggerPhoneEnding() {
    if (nightmareActive) {
        showDialogue("The line only carries breathing now.", 2000, 'phone');
        return;
    }
    if (phoneEndingActive || endingTriggered) return;
    phoneEndingActive = true;
    dialogueSourceLock = 'phone';
    sleepTransitionActive = true;
    setNightmareBatteryVisibility(false);
    updateBatteryHud();
    if (ambientInterval) clearInterval(ambientInterval);
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();

    // Clear any previous subtitle that might still be fading.
    if (DOM.dialogue) {
        clearTimeout(DOM.dialogue._hideTimer);
        clearTimeout(DOM.dialogue._displayNoneTimer);
        DOM.dialogue.style.display = 'none';
        DOM.dialogue.style.opacity = '0';
    }
    if (DOM.thought) {
        clearTimeout(DOM.thought._hideTimer);
        clearTimeout(DOM.thought._displayNoneTimer);
        DOM.thought.style.display = 'none';
        DOM.thought.style.opacity = '0';
    }

    phoneBuzzActiveTimer = 0;
    if (phoneScreenMat) phoneScreenMat.emissiveIntensity = 2.5;
    if (phoneLight) phoneLight.intensity = 1.2;

    const line1 = "Hello...?";
    const line2 = "...";
    const line3 = "\"...I can see you...\"";
    const line4 = "\"Look... behind... you...\"";
    const line5 = "\"...I'm behind you...\"";

    const d1 = getPhoneLineSubtitleDuration(line1);
    const d2 = getPhoneLineSubtitleDuration(line2);
    const d3 = getPhoneLineSubtitleDuration(line3);
    const d4 = getPhoneLineSubtitleDuration(line4);
    const d5 = getPhoneLineSubtitleDuration(line5);
    const gap = 350;

    showDialogue(line1, d1, 'phone');
    playUncannyPhoneVoiceLine(line1, 'phone');
    playPhoneStaticVoice();

    let timeline = d1 + gap;
    setTimeout(() => {
        showDialogue(line2, d2, 'phone');
        playUncannyPhoneVoiceLine(line2, 'phone');
    }, timeline);

    timeline += d2 + gap;
    setTimeout(() => {
        playWhisper();
        showDialogue(line3, d3, 'phone');
        playUncannyPhoneVoiceLine(line3, 'phone');
        showThought("who is this?", Math.max(2200, d3 - 400), 'phone');
    }, timeline);

    timeline += d3 + gap;
    setTimeout(() => {
        playDrone(25, 5);
        showDialogue(line4, d4, 'phone');
        playUncannyPhoneVoiceLine(line4, 'phone');
    }, timeline);

    const sleepFade = document.getElementById('sleep-fade');
    const fadeAt = timeline + Math.max(500, d4 - 700);
    setTimeout(() => {
        sleepFade.style.transition = 'opacity 0.8s ease';
        sleepFade.style.opacity = '1';
        if (phoneScreenMat) phoneScreenMat.emissiveIntensity = 0;
        if (phoneLight) phoneLight.intensity = 0;
    }, fadeAt);

    timeline += d4 + gap;
    setTimeout(() => {
        playUncannyPhoneVoiceLine(line5, 'phone');
        showDialogue(line5, d5, 'phone');
    }, timeline);

    const screamAt = timeline + Math.max(700, d5 - 900);
    setTimeout(() => {
        playScream();
        triggerScreenFlash(1, 100, 300);
    }, screamAt);

    const endingAt = timeline + d5 + 650;
    setTimeout(() => {
        if (endingTriggered) return;
        endingTriggered = true;
        showEndingScreen("THE LINE WAS NEVER DEAD", "Someone was always on the other end.", "phoneLine");
    }, endingAt);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    const q = QUALITY_PRESETS[gameSettings.quality] || QUALITY_PRESETS.high;
    renderer.setPixelRatio(q.pixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function setMobileControlsActive(active) {
    if (!isMobileDevice) return;
    const controls = document.getElementById('mobile-controls');
    if (!controls) return;
    if (!active) {
        resetMobileMoveState();
        mobileLookTouchId = null;
        interactKeyHeld = false;
        bedHoldSeconds = 0;
        closetHoldSeconds = 0;
    }
    controls.classList.toggle('active', !!active);
}

function setMobileMoveVector(x, y) {
    mobileMoveVectorX = Math.max(-1, Math.min(1, x));
    mobileMoveVectorY = Math.max(-1, Math.min(1, y));

    const deadZone = 0.16;
    moveLeft = mobileMoveVectorX < -deadZone;
    moveRight = mobileMoveVectorX > deadZone;
    moveForward = mobileMoveVectorY < -deadZone;
    moveBackward = mobileMoveVectorY > deadZone;

    const stick = document.getElementById('mobile-left-stick');
    if (stick) {
        const travel = 30;
        stick.style.transform = `translate(calc(-50% + ${(mobileMoveVectorX * travel).toFixed(1)}px), calc(-50% + ${(mobileMoveVectorY * travel).toFixed(1)}px))`;
    }
}

function resetMobileMoveState() {
    mobileMoveTouchId = null;
    setMobileMoveVector(0, 0);
}

function findChangedTouchById(touchList, id) {
    for (let i = 0; i < touchList.length; i++) {
        if (touchList[i].identifier === id) return touchList[i];
    }
    return null;
}

function updateMobileMoveFromTouch(touch, padEl) {
    if (!touch || !padEl) return;
    const rect = padEl.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    let nx = (touch.clientX - cx) / (rect.width / 2);
    let ny = (touch.clientY - cy) / (rect.height / 2);
    const mag = Math.hypot(nx, ny);
    if (mag > 1) {
        nx /= mag;
        ny /= mag;
    }
    setMobileMoveVector(nx, ny);
}

function applyMobileLookDelta(dx, dy) {
    const sensitivity = (gameSettings.sensitivity || 0.002) * 1.08;
    yaw -= dx * sensitivity;
    pitch -= dy * sensitivity;
    pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
}

function setupMobileControls() {
    if (!isMobileDevice || mobileControlsReady) return;
    mobileControlsReady = true;
    document.body.classList.add('mobile-mode');
    if (renderer && renderer.domElement) {
        renderer.domElement.style.touchAction = 'none';
    }

    const warningEl = document.querySelector('#overlay .warning');
    if (warningEl) {
        warningEl.textContent = 'Mobile mode: left pad move, right pad look, hold INTERACT to sleep/hide.';
    }

    const leftPad = document.getElementById('mobile-left-pad');
    const rightPad = document.getElementById('mobile-right-pad');
    const interactBtn = document.getElementById('mobile-interact-btn');
    const flashlightBtn = document.getElementById('mobile-flashlight-btn');
    const pauseBtn = document.getElementById('mobile-pause-btn');
    if (!leftPad || !rightPad || !interactBtn || !flashlightBtn) return;

    const startTouchMove = (e) => {
        if (!gameStarted || gamePaused || gameboyActive || sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
        if (mobileMoveTouchId !== null) return;
        const touch = e.changedTouches[0];
        if (!touch) return;
        mobileMoveTouchId = touch.identifier;
        updateMobileMoveFromTouch(touch, leftPad);
        e.preventDefault();
    };
    const moveTouchMove = (e) => {
        if (mobileMoveTouchId === null) return;
        const touch = findChangedTouchById(e.changedTouches, mobileMoveTouchId);
        if (!touch) return;
        updateMobileMoveFromTouch(touch, leftPad);
        e.preventDefault();
    };
    const endTouchMove = (e) => {
        if (mobileMoveTouchId === null) return;
        if (!findChangedTouchById(e.changedTouches, mobileMoveTouchId)) return;
        resetMobileMoveState();
        e.preventDefault();
    };

    leftPad.addEventListener('touchstart', startTouchMove, { passive: false });
    leftPad.addEventListener('touchmove', moveTouchMove, { passive: false });
    leftPad.addEventListener('touchend', endTouchMove, { passive: false });
    leftPad.addEventListener('touchcancel', endTouchMove, { passive: false });

    const startTouchLook = (e) => {
        if (!gameStarted || gamePaused || gameboyActive || sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
        if (mobileLookTouchId !== null) return;
        const touch = e.changedTouches[0];
        if (!touch) return;
        mobileLookTouchId = touch.identifier;
        mobileLookLastX = touch.clientX;
        mobileLookLastY = touch.clientY;
        e.preventDefault();
    };
    const moveTouchLook = (e) => {
        if (mobileLookTouchId === null) return;
        const touch = findChangedTouchById(e.changedTouches, mobileLookTouchId);
        if (!touch) return;
        const dx = touch.clientX - mobileLookLastX;
        const dy = touch.clientY - mobileLookLastY;
        mobileLookLastX = touch.clientX;
        mobileLookLastY = touch.clientY;
        applyMobileLookDelta(dx, dy);
        e.preventDefault();
    };
    const endTouchLook = (e) => {
        if (mobileLookTouchId === null) return;
        if (!findChangedTouchById(e.changedTouches, mobileLookTouchId)) return;
        mobileLookTouchId = null;
        e.preventDefault();
    };

    rightPad.addEventListener('touchstart', startTouchLook, { passive: false });
    rightPad.addEventListener('touchmove', moveTouchLook, { passive: false });
    rightPad.addEventListener('touchend', endTouchLook, { passive: false });
    rightPad.addEventListener('touchcancel', endTouchLook, { passive: false });

    const releaseInteract = (e) => {
        interactKeyHeld = false;
        bedHoldSeconds = 0;
        closetHoldSeconds = 0;
        interactBtn.classList.remove('pressed');
        if (e) e.preventDefault();
    };

    interactBtn.addEventListener('touchstart', (e) => {
        if (!gameStarted || gamePaused || gameboyActive || sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
        interactKeyHeld = true;
        tryInteract();
        interactBtn.classList.add('pressed');
        e.preventDefault();
    }, { passive: false });
    interactBtn.addEventListener('touchend', releaseInteract, { passive: false });
    interactBtn.addEventListener('touchcancel', releaseInteract, { passive: false });

    flashlightBtn.addEventListener('touchstart', (e) => {
        if (!gameStarted || gamePaused || gameboyActive || !flashlightHeld || sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
        if (nightmareActive && blackoutTriggered && flashlightBattery <= 0.001) {
            showDialogue("No fluid left. Need a lighter.", 1700);
            e.preventDefault();
            return;
        }
        flashlightOn = !flashlightOn;
        flashlightBtn.classList.add('pressed');
        setTimeout(() => flashlightBtn.classList.remove('pressed'), 130);
        showDialogue(
            flashlightOn
                ? (nightmareActive ? "Lantern on." : "Flashlight on.")
                : (nightmareActive ? "Lantern off." : "Flashlight off."),
            1200
        );
        updateBatteryHud();
        e.preventDefault();
    }, { passive: false });

    if (pauseBtn) {
        pauseBtn.addEventListener('touchstart', (e) => {
            if (!gameStarted || endingTriggered || gameStartInProgress || phoneEndingActive || closetEndingActive) return;
            pauseBtn.classList.add('pressed');
            setTimeout(() => pauseBtn.classList.remove('pressed'), 130);
            togglePauseMenu();
            e.preventDefault();
        }, { passive: false });
    }

    document.addEventListener('touchend', (e) => {
        if (!gameStarted) return;
        if (mobileMoveTouchId !== null && findChangedTouchById(e.changedTouches, mobileMoveTouchId)) {
            resetMobileMoveState();
        }
        if (mobileLookTouchId !== null && findChangedTouchById(e.changedTouches, mobileLookTouchId)) {
            mobileLookTouchId = null;
        }
    }, { passive: false });

    setupGameBoyMobileControls();
}

function setupGameBoyMobileControls() {
    if (!isMobileDevice) return;
    const dpad = document.getElementById('gameboy-snake-dpad');
    const restartBtn = document.getElementById('gameboy-snake-restart');
    const closeBtn = document.getElementById('gameboy-close-btn');
    if (!dpad || !restartBtn) return;

    dpad.querySelectorAll('.dpad-btn').forEach(btn => {
        const dir = btn.dataset.dir;
        if (!dir) return;
        const setDir = (e) => {
            e.preventDefault();
            if (!gameboyActive || !snakeAlive) return;
            const d = snakeNextDir || snakeDir;
            switch (dir) {
                case 'up':    if (d.y !== 1)  snakeNextDir = {x:0,y:-1}; break;
                case 'down':  if (d.y !== -1) snakeNextDir = {x:0,y:1};  break;
                case 'left':  if (d.x !== 1)  snakeNextDir = {x:-1,y:0}; break;
                case 'right': if (d.x !== -1) snakeNextDir = {x:1,y:0};  break;
            }
        };
        btn.addEventListener('touchstart', setDir, { passive: false });
        btn.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
    });

    restartBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!gameboyActive) return;
        if (!snakeAlive) startSnakeGame();
    }, { passive: false });

    if (closeBtn) {
        closeBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameboyActive) closeGameBoy();
        }, { passive: false });
    }
}

function onKeyDown(e) {
    if (gameboyActive) {
        e.preventDefault();
        if (e.code === 'Escape' || e.code === 'Tab') {
            closeGameBoy();
            return;
        }
        if (!snakeAlive && e.code === 'Space') {
            startSnakeGame();
            return;
        }
        if (snakeAlive) {
            const d = snakeNextDir || snakeDir;
            switch (e.code) {
                case 'KeyW': case 'ArrowUp':    if (d.y !== 1)  snakeNextDir = {x:0,y:-1}; break;
                case 'KeyS': case 'ArrowDown':  if (d.y !== -1) snakeNextDir = {x:0,y:1};  break;
                case 'KeyA': case 'ArrowLeft':   if (d.x !== 1)  snakeNextDir = {x:-1,y:0}; break;
                case 'KeyD': case 'ArrowRight':  if (d.x !== -1) snakeNextDir = {x:1,y:0};  break;
            }
        }
        return;
    }
    if (e.code === 'Escape') {
        e.preventDefault();
        if (gameStarted) togglePauseMenu();
        return;
    }
    if (!gameStarted || gamePaused || sleepTransitionActive || closetEndingActive || phoneEndingActive) return;
    if (e.code === 'Tab') {
        e.preventDefault();
        if (gameboyHeld) openGameBoy();
        return;
    }
    switch (e.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'ShiftLeft':
        case 'ShiftRight':
            sprintHeld = true;
            break;
        case 'KeyE':
            if (e.repeat) break;
            interactKeyHeld = true;
            tryInteract();
            break;
    }
}

function onKeyUp(e) {
    switch (e.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft':
        case 'ShiftRight':
            sprintHeld = false;
            break;
        case 'KeyE':
            interactKeyHeld = false;
            bedHoldSeconds = 0;
            closetHoldSeconds = 0;
            break;
    }
}

function onMouseMove(e) {
    if (isMobileDevice) return;
    if (!gameStarted || gamePaused || !document.pointerLockElement) return;
    const sensitivity = gameSettings.sensitivity || 0.002;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
}

function onClick() {
    if (isMobileDevice) return;
    if (gameStarted && !gamePaused && !document.pointerLockElement && renderer.domElement.requestPointerLock) {
        renderer.domElement.requestPointerLock();
    }
}

function tryInteract() {
    if (gamePaused || closetEndingActive || sleepTransitionActive || phoneEndingActive) return;
    _reusableForward.set(0, 0, -1);
    _reusableEuler.set(pitch, yaw, 0, 'YXZ');
    _reusableForward.applyEuler(_reusableEuler);
    _reusableRaycaster.set(camera.position, _reusableForward);
    _reusableRaycaster.near = 0;
    _reusableRaycaster.far = 2.5;
    const raycaster = _reusableRaycaster;

    // Check door
    const doorHits = raycaster.intersectObject(doorMesh);
    if (doorHits.length > 0) {
        if (doorUnlocked) {
            if (!doorOpened) {
                doorOpened = true;
                let t = 0;
                const openAnim = setInterval(() => {
                    t += 0.055;
                    doorOpenAngle = Math.min(Math.PI / 2, t * (Math.PI / 2));
                    if (doorHingeGroup) doorHingeGroup.rotation.y = -doorOpenAngle;
                    if (doorOpenAngle >= Math.PI / 2) clearInterval(openAnim);
                }, 16);
                showDialogue("The door opens... finally.", 1800);
                setTimeout(() => triggerSleptThroughEnding(), 1200);
            }
            return;
        }

        doorAttempts++;
        const msgs = [
            "It won't open...",
            "It's locked. It's always been locked.",
            "Why won't it open? WHY WON'T IT OPEN?",
            "I... I don't think there's anything on the other side.",
            "Stop trying. You know it doesn't open.",
            "The door has never opened. Has it?",
            "There is no outside.",
        ];
        showDialogue(msgs[Math.min(doorAttempts - 1, msgs.length - 1)], 3000);
        playTone(200, 0.3, 'sine', 0.05);

        return;
    }

    // Check wall light switch
    if (houseLightSwitchMesh) {
        const switchHits = raycaster.intersectObject(houseLightSwitchMesh);
        if (switchHits.length > 0) {
            if (blackoutTriggered && !sleepEndingActive) {
                showDialogue("No power. The switch does nothing.", 2000);
                return;
            }

            houseLightsOn = !houseLightsOn;
            if (ceilingLight) ceilingLight.intensity = houseLightsOn ? (sleepEndingActive ? 1.05 : 0.4) : 0;
            if (houseLightSwitchLever) houseLightSwitchLever.rotation.x = houseLightsOn ? -0.45 : 0.45;
            playTone(houseLightsOn ? 820 : 420, 0.05, 'square', 0.03);
            showDialogue(houseLightsOn ? "Ceiling light on." : "Ceiling light off.", 1400);
            return;
        }
    }

    // Check lamp switch area
    if (lampInteractMesh) {
        const lampHits = raycaster.intersectObject(lampInteractMesh);
        if (lampHits.length > 0) {
            if (blackoutTriggered && !sleepEndingActive) {
                showDialogue("No power. The lamp won't turn on.", 2000);
                return;
            }

            lampOn = !lampOn;
            if (lampLight) lampLight.intensity = lampOn ? (sleepEndingActive ? 0.28 : 0.5) : 0;
            if (lampBulbMat) lampBulbMat.emissiveIntensity = lampOn ? (sleepEndingActive ? 1.4 : 2) : 0;
            playTone(lampOn ? 760 : 380, 0.05, 'square', 0.03);
            showDialogue(lampOn ? "Lamp on." : "Lamp off.", 1400);
            return;
        }
    }

    // Check window
    const winHits = raycaster.intersectObject(windowMesh);
    if (winHits.length > 0) {
        if (sleepEndingActive) {
            showDialogue("Nice morning... the field looks peaceful.", 3000);
            return;
        }
        if (phase >= 3) {
            showDialogue("Something is out there... I can feel it watching me.", 3000);
            playDrone(60, 3);
        } else {
            showDialogue("It's dark... but I can barely make out the field.", 3000);
        }
        return;
    }

    // Check closet
    if (closetDoor) {
        const closetHits = raycaster.intersectObject(closetDoor);
        if (closetHits.length > 0) {
            if (sleepEndingActive) {
                showDialogue("Just my closet. Nothing weird in there.", 2500);
                return;
            }

            if (!isClosetEndingUnlocked()) {
                const unlocked = unlockedEndingCount();
                showDialogue(`It's stuck. Maybe after I see every ending (${unlocked}/${REQUIRED_ENDINGS_FOR_CLOSET.length}).`, 2800);
                return;
            }

            showDialogue("Just old clothes... I can hold E to hide.", 2400);
            return;
        }
    }

    // Check mirror
    if (mirrorInteractMesh) {
        const mirrorHits = raycaster.intersectObject(mirrorInteractMesh, true);
        if (mirrorHits.length > 0) {
            if (sleepEndingActive) {
                showDialogue("Just a mirror in morning light.", 2200);
            } else if (phase >= 7) {
                showDialogue("That reflection moved before I did.", 2500);
                playWhisper();
            } else if (phase >= 4) {
                showDialogue("I look exhausted.", 2200);
            } else {
                showDialogue("Just me.", 1600);
            }
            return;
        }
    }

    // Check Game Boy
    if (gameboyMesh) {
        const gbHits = raycaster.intersectObject(gameboyMesh, true);
        if (gbHits.length > 0) {
            if (!gameboyHeld) {
                gameboyHeld = true;
                gameboyMesh.visible = false;
                addToInventory('gameboy', 'Game Boy', '\u{1F3AE}');
            } else {
                openGameBoy();
            }
            return;
        }
    }

    // Check phone
    if (phoneMesh) {
        const phoneHits = raycaster.intersectObject(phoneMesh, true);
        if (phoneHits.length > 0) {
            if (sleepEndingActive) {
                showDialogue("No signal up here. Figures.", 2500);
                return;
            }
            if (nightmareActive && phoneBuzzActiveTimer > 0) {
                showDialogue("Only breathing... right behind me.", 2500);
                playEarWhisper();
                return;
            }
            if (phoneBuzzActiveTimer > 0 && !phoneAnsweredOnce) {
                phoneAnsweredOnce = true;
                triggerPhoneEnding();
                return;
            }
            if (phoneBuzzActiveTimer > 0 && Math.random() < 0.15) {
                triggerPhoneEnding();
                return;
            }
            if (phoneBuzzActiveTimer > 0) {
                const buzzLines = [
                    "...just static. Nobody there.",
                    "I don't recognize this number...",
                    "Who would call at this hour?"
                ];
                showDialogue(buzzLines[Math.floor(Math.random() * buzzLines.length)], 2500);
            } else {
                showDialogue("My phone. No signal, no messages.", 2200);
            }
            return;
        }
    }

    // Nightmare battery packs
    if (nightmareActive) {
        const batteryPack = getLookedAtNightmareBattery(raycaster);
        if (batteryPack) {
            collectNightmareBattery(batteryPack);
            return;
        }
    }

    // Pick up light source
    if (flashlightMesh && !flashlightHeld) {
        const flashlightHits = raycaster.intersectObject(flashlightMesh, true);
        if (flashlightHits.length > 0) {
            if (!blackoutTriggered) {
                flashlightLookAttempts++;
                const beforeDarkLines = nightmareActive ? [
                    "I don't need the lantern yet.",
                    "It's not that dark.",
                    "The lights are still on."
                ] : [
                    "I don't need the flashlight yet.",
                    "It's fine. The lights are still on.",
                    "I'll pick it up if I need it."
                ];
                showDialogue(beforeDarkLines[Math.min(flashlightLookAttempts - 1, beforeDarkLines.length - 1)], 2500);
                return;
            }
            flashlightHeld = true;
            flashlightOn = true;
            flashlightMesh.visible = false;
            if (flashlightHintLight) flashlightHintLight.intensity = 0;
            const toggleHint = isMobileDevice ? "Tap LIGHT to toggle." : "Press F to toggle.";
            showDialogue(nightmareActive ? `Lantern picked up. ${toggleHint}` : `Flashlight picked up. ${toggleHint}`, 3200);
            if (nightmareActive) {
                showThought("the fluid drains fast in this mode...");
            }
            updateBatteryHud();
            return;
        }
    }
}

function updateMovement(dt) {
    if (gamePaused || sleepTransitionActive || closetEndingActive || phoneEndingActive || gameboyActive) return;
    const speed = sprintHeld ? 3.6 : 2.5;
    const dir = new THREE.Vector3();

    if (moveForward) dir.z -= 1;
    if (moveBackward) dir.z += 1;
    if (moveLeft) dir.x -= 1;
    if (moveRight) dir.x += 1;

    isMoving = dir.length() > 0;

    if (isMoving) {
        if (sprintHeld) {
            if (walkingAudio.currentTime > 0 && !walkingAudio.paused) walkingAudio.pause();
            if (runningAudio.paused) runningAudio.play().catch(e => console.warn(e));
        } else {
            if (runningAudio.currentTime > 0 && !runningAudio.paused) runningAudio.pause();
            if (walkingAudio.paused) walkingAudio.play().catch(e => console.warn(e));
        }
        
        dir.normalize();
        dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        dir.multiplyScalar(speed * dt);

        const newX = camera.position.x + dir.x;
        const newZ = camera.position.z + dir.z;
        if (canMoveTo(newX, camera.position.z)) camera.position.x = newX;
        if (canMoveTo(camera.position.x, newZ)) camera.position.z = newZ;

        headBob += dt * 8;
    }

    camera.position.y = playerHeight + (isMoving ? Math.sin(headBob) * 0.03 : 0);

    if (!isMoving) {
        if (!walkingAudio.paused) walkingAudio.pause();
        if (!runningAudio.paused) runningAudio.pause();
    }

    // Breathing effect in later phases
    if (phase >= 6) {
        breathingRate += dt * 2;
        camera.position.y += Math.sin(breathingRate) * 0.01;
    }

    camera.rotation.set(0, 0, 0);
    camera.rotateOnAxis(new THREE.Vector3(0, 1, 0), yaw);
    camera.rotateOnAxis(new THREE.Vector3(1, 0, 0), pitch);
}

function updateInteractPrompt() {
    _reusableForward.set(0, 0, -1);
    _reusableEuler.set(pitch, yaw, 0, 'YXZ');
    _reusableForward.applyEuler(_reusableEuler);
    _reusableRaycaster.set(camera.position, _reusableForward);
    _reusableRaycaster.near = 0;
    _reusableRaycaster.far = 2.5;
    const raycaster = _reusableRaycaster;

    let showPrompt = false;
    let promptText = "[ E ]";
    if (doorMesh && raycaster.intersectObject(doorMesh).length > 0) showPrompt = true;
    if (windowMesh && raycaster.intersectObject(windowMesh).length > 0) showPrompt = true;
    if (closetDoor && raycaster.intersectObject(closetDoor).length > 0) {
        showPrompt = true;
        if (isClosetEndingUnlocked()) {
            const remain = Math.max(0, closetHoldRequired - closetHoldSeconds).toFixed(1);
            promptText = interactKeyHeld
                ? `[ E ] CHECK CLOSET | [ HOLD E ] HIDE ${remain}s`
                : "[ E ] CHECK CLOSET | [ HOLD E ] HIDE";
        } else {
            promptText = `[ E ] CHECK CLOSET (${unlockedEndingCount()}/${REQUIRED_ENDINGS_FOR_CLOSET.length})`;
        }
    }
    if (houseLightSwitchMesh && raycaster.intersectObject(houseLightSwitchMesh).length > 0) {
        showPrompt = true;
        promptText = houseLightsOn ? "[ E ] LIGHTS OFF" : "[ E ] LIGHTS ON";
    }
    if (lampInteractMesh && raycaster.intersectObject(lampInteractMesh).length > 0) {
        showPrompt = true;
        promptText = lampOn ? "[ E ] LAMP OFF" : "[ E ] LAMP ON";
    }
    if (mirrorInteractMesh && raycaster.intersectObject(mirrorInteractMesh, true).length > 0) {
        showPrompt = true;
        promptText = "[ E ] MIRROR";
    }
    const batteryPromptTarget = getLookedAtNightmareBattery(raycaster);
    if (batteryPromptTarget) {
        showPrompt = true;
        const chargePct = Math.round((batteryPromptTarget.userData.charge || 0.35) * 100);
        promptText = nightmareActive ? `[ E ] FLUID +${chargePct}%` : `[ E ] BATTERY +${chargePct}%`;
    }
    if (gameboyMesh && gameboyMesh.visible && raycaster.intersectObject(gameboyMesh, true).length > 0) {
        showPrompt = true;
        promptText = "[ E ] PICK UP GAME BOY";
    }
    if (flashlightMesh && !flashlightHeld && raycaster.intersectObject(flashlightMesh, true).length > 0) {
        showPrompt = true;
        promptText = nightmareActive ? "[ E ] PICK UP LANTERN" : "[ E ] PICK UP FLASHLIGHT";
    }
    if (phoneMesh && raycaster.intersectObject(phoneMesh, true).length > 0) {
        showPrompt = true;
        promptText = phoneBuzzActiveTimer > 0 ? "[ E ] ANSWER" : "[ E ] PHONE";
    }
    if (bedGroupRef && !sleepEndingActive && raycaster.intersectObject(bedGroupRef, true).length > 0) {
        showPrompt = true;
        const remain = Math.max(0, 5 - bedHoldSeconds).toFixed(1);
        promptText = interactKeyHeld ? `[ HOLD E ] SLEEP ${remain}s` : "[ HOLD E ] SLEEP";
    } else if (doorUnlocked && doorMesh && raycaster.intersectObject(doorMesh).length > 0) {
        promptText = "[ E ] OPEN DOOR";
    }

    const promptEl = DOM.interactPrompt;
    if (promptEl) {
        promptEl.textContent = formatPromptForDevice(promptText);
        promptEl.style.display = showPrompt ? 'block' : 'none';
    }
}

let flashlightSwayTime = 0;
const _reusableRaycaster = new THREE.Raycaster();
const _reusableForward = new THREE.Vector3();
const _reusableEuler = new THREE.Euler();

function updateFlashlight() {
    if (!flashlightLight || !camera) return;
    if (flashlightHintLight && !flashlightHeld && blackoutTriggered) {
        flashlightHintLight.intensity = 1.0 + Math.sin(gameTime * 6) * 0.35;
    } else if (flashlightHintLight) {
        flashlightHintLight.intensity = 0;
    }

    if (nightmareActive && blackoutTriggered && flashlightBattery <= 0.001) {
        flashlightOn = false;
    }

    if (!flashlightHeld || !flashlightOn) {
        flashlightLight.intensity = 0;
        if (flashlightFillLight) flashlightFillLight.intensity = 0;
        updateBatteryHud();
        return;
    }

    flashlightSwayTime += 0.016;

    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
    const up = new THREE.Vector3(0, 1, 0);

    const swayX = Math.sin(flashlightSwayTime * 2.3) * 0.012 * (isMoving ? 3 : 1);
    const swayY = Math.cos(flashlightSwayTime * 1.7) * 0.01 * (isMoving ? 2.5 : 1);

    const batteryFactor = nightmareActive && blackoutTriggered
        ? Math.max(0.18, flashlightBattery)
        : 1;

    let unstableFlicker = 1;
    if (nightmareActive && blackoutTriggered && flashlightBattery < 0.25) {
        const flickerChance = flashlightBattery < 0.1 ? 0.25 : 0.14;
        if (Math.random() < flickerChance) {
            unstableFlicker = flashlightBattery < 0.1 ? 0.15 + Math.random() * 0.3 : 0.35;
        }
    }

    const baseIntensity = nightmareActive ? 3.8 : 1.6;
    flashlightLight.intensity = baseIntensity * batteryFactor * unstableFlicker;

    if (nightmareActive) {
        const warmth = batteryFactor > 0.5 ? 0xffaa44 : 0xff7722; // Lantern is more orange
        flashlightLight.color.setHex(warmth);

        // Lantern sits near center chest so it lights floor and walls all around.
        flashlightLight.position.copy(camera.position)
            .add(forward.clone().multiplyScalar(0.06 + swayY * 0.4))
            .add(up.clone().multiplyScalar(-0.22));

        if (flashlightFillLight) {
            flashlightFillLight.intensity = 0.85 * batteryFactor * unstableFlicker;
            flashlightFillLight.color.setHex(warmth);
            flashlightFillLight.position.copy(camera.position).add(up.clone().multiplyScalar(-0.08));
        }
    } else {
        const warmth = batteryFactor > 0.5 ? 0xffeedd : 0xffcc88;
        flashlightLight.color.setHex(warmth);

        // Position flashlight in hand
        flashlightLight.position.copy(camera.position)
            .add(forward.clone().multiplyScalar(0.12))
            .add(right.clone().multiplyScalar(0.1))
            .add(up.clone().multiplyScalar(-0.06));

        // Update spotlight target
        const targetPos = camera.position.clone()
            .add(forward.clone().multiplyScalar(8))
            .add(right.clone().multiplyScalar(swayX))
            .add(up.clone().multiplyScalar(swayY));
        if (flashlightTarget) flashlightTarget.position.copy(targetPos);

        if (flashlightFillLight) {
            flashlightFillLight.intensity = 0.25 * batteryFactor * unstableFlicker;
            flashlightFillLight.color.setHex(warmth);
            flashlightFillLight.position.copy(camera.position).add(forward.clone().multiplyScalar(0.4));
        }
    }
    updateBatteryHud();
}

function updatePhone(dt) {
    if (!phoneMesh || !phoneScreenMat || !phoneLight) return;

    if (sleepEndingActive || sleepTransitionActive || closetEndingActive || phoneEndingActive || endingTriggered) {
        phoneBuzzActiveTimer = 0;
        phoneScreenMat.emissiveIntensity = 0.02;
        phoneLight.intensity = 0;
        if (phoneMesh.userData.basePos) phoneMesh.position.copy(phoneMesh.userData.basePos);
        return;
    }

    if (phoneBuzzActiveTimer > 0) {
        phoneBuzzActiveTimer -= dt;
        const phaseT = gameTime * 80;
        if (phoneMesh.userData.basePos) {
            phoneMesh.position.copy(phoneMesh.userData.basePos);
            phoneMesh.position.x += Math.sin(phaseT) * 0.0045;
            phoneMesh.position.z += Math.cos(phaseT * 1.1) * 0.0035;
        }
        phoneScreenMat.emissiveIntensity = 2.15;
        phoneLight.intensity = 0.92;
        if (phoneBuzzActiveTimer <= 0) {
            phoneScreenMat.emissiveIntensity = 0.02;
            phoneLight.intensity = 0;
            if (phoneMesh.userData.basePos) phoneMesh.position.copy(phoneMesh.userData.basePos);
        }
        return;
    }

    // Poisson-style random trigger: no schedule pattern.
    if (Math.random() < dt * 0.045) {
        phoneBuzzActiveTimer = 1.0;
        playPhoneBuzzSound();
    }
}

function updateGamepad(dt) {
    const gp = navigator.getGamepads ? navigator.getGamepads() : [];
    const pad = gp[0] || gp[1];
    if (!pad || !pad.connected) return;

    if (gameboyActive) {
        if (snakeAlive) {
            const thresh = 0.5;
            let dx = 0, dy = 0;
            if (pad.axes.length >= 2) {
                dx = Math.abs(pad.axes[0]) > thresh ? pad.axes[0] : 0;
                dy = Math.abs(pad.axes[1]) > thresh ? pad.axes[1] : 0;
            }
            if (pad.buttons[14] && pad.buttons[14].pressed) dx = -1;
            if (pad.buttons[15] && pad.buttons[15].pressed) dx = 1;
            if (pad.buttons[12] && pad.buttons[12].pressed) dy = -1;
            if (pad.buttons[13] && pad.buttons[13].pressed) dy = 1;
            const d = snakeNextDir || snakeDir;
            if (dy < -thresh && d.y !== 1)  snakeNextDir = {x:0,y:-1};
            else if (dy > thresh && d.y !== -1) snakeNextDir = {x:0,y:1};
            else if (dx < -thresh && d.x !== 1)  snakeNextDir = {x:-1,y:0};
            else if (dx > thresh && d.x !== -1) snakeNextDir = {x:1,y:0};
        }
        if (!snakeAlive && pad.buttons[0] && pad.buttons[0].pressed && !pad.buttons[0]._used) {
            pad.buttons[0]._used = true;
            startSnakeGame();
        }
        if (pad.buttons[0] && !pad.buttons[0].pressed) pad.buttons[0]._used = false;
        const closeBtn = (pad.buttons[9] && pad.buttons[9].pressed) || (pad.buttons[8] && pad.buttons[8].pressed);
        if (closeBtn && !pad._closeUsed) { pad._closeUsed = true; closeGameBoy(); }
        if (!closeBtn) pad._closeUsed = false;
        return;
    }

    if (gamePaused) {
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        sprintHeld = false;
        interactKeyHeld = false;
        return;
    }

    if (!gameStarted || sleepTransitionActive || closetEndingActive || phoneEndingActive || endingTriggered) return;

    const moveThresh = 0.4;
    if (pad.axes.length >= 2) {
        moveLeft = pad.axes[0] < -moveThresh;
        moveRight = pad.axes[0] > moveThresh;
        moveForward = pad.axes[1] < -moveThresh;
        moveBackward = pad.axes[1] > moveThresh;
    }
    if (pad.buttons[14]) moveLeft = moveLeft || pad.buttons[14].pressed;
    if (pad.buttons[15]) moveRight = moveRight || pad.buttons[15].pressed;
    if (pad.buttons[12]) moveForward = moveForward || pad.buttons[12].pressed;
    if (pad.buttons[13]) moveBackward = moveBackward || pad.buttons[13].pressed;

    if (pad.axes.length >= 4) {
        const lookSens = (gameSettings.sensitivity || 0.002) * 45;
        yaw -= pad.axes[2] * lookSens * dt * 60;
        pitch -= pad.axes[3] * lookSens * dt * 60;
        pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, pitch));
    }

    sprintHeld = (pad.buttons[4] && pad.buttons[4].pressed) || (pad.buttons[6] && pad.buttons[6].value > 0.5);
    const aPressed = pad.buttons[0] && pad.buttons[0].pressed;
    if (aPressed && !pad.buttons[0]._interactTriggered) {
        pad.buttons[0]._interactTriggered = true;
        tryInteract();
    }
    if (!aPressed) pad.buttons[0]._interactTriggered = false;
    interactKeyHeld = aPressed;

    if (pad.buttons[1] && pad.buttons[1].pressed && !pad.buttons[1]._flashUsed) {
        pad.buttons[1]._flashUsed = true;
        if (flashlightHeld) {
            if (nightmareActive && blackoutTriggered && flashlightBattery <= 0.001) { /* noop */ }
            else {
                flashlightOn = !flashlightOn;
                showDialogue(flashlightOn ? (nightmareActive ? "Lantern on." : "Flashlight on.") : (nightmareActive ? "Lantern off." : "Flashlight off."), 1200);
                updateBatteryHud();
            }
        }
    }
    if (pad.buttons[1] && !pad.buttons[1].pressed) pad.buttons[1]._flashUsed = false;

    if (pad.buttons[2] && pad.buttons[2].pressed && !pad.buttons[2]._gbUsed) {
        pad.buttons[2]._gbUsed = true;
        if (gameboyHeld) openGameBoy();
    }
    if (pad.buttons[2] && !pad.buttons[2].pressed) pad.buttons[2]._gbUsed = false;
}

function animate() {
    if (endingTriggered && phase > 9) return;
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);

    if (gameStarted && !gamePaused) {
        updateGamepad(dt);
        if (!sleepEndingActive && !phoneEndingActive && interactKeyHeld) {
            _reusableForward.set(0, 0, -1);
            _reusableEuler.set(pitch, yaw, 0, 'YXZ');
            _reusableForward.applyEuler(_reusableEuler);
            _reusableRaycaster.set(camera.position, _reusableForward);
            _reusableRaycaster.near = 0;
            _reusableRaycaster.far = 2.5;
            const raycaster = _reusableRaycaster;

            if (bedGroupRef) {
                const bedLookHits = raycaster.intersectObject(bedGroupRef, true);
                if (bedLookHits.length > 0) {
                    bedHoldSeconds += dt;
                    if (bedHoldSeconds >= 5) {
                        if (nightmareActive) {
                            showDialogue("You can't wake up yet.", 1600);
                        } else {
                            triggerSleepEndingStart();
                        }
                        bedHoldSeconds = 0;
                    }
                } else {
                    bedHoldSeconds = 0;
                }
            }

            if (closetDoor && isClosetEndingUnlocked() && !closetEndingActive && !sleepTransitionActive && !nightmareActive) {
                const closetHits = raycaster.intersectObject(closetDoor);
                if (closetHits.length > 0) {
                    closetHoldSeconds += dt;
                    if (closetHoldSeconds >= closetHoldRequired) {
                        triggerClosetEnding();
                        closetHoldSeconds = 0;
                    }
                } else {
                    closetHoldSeconds = 0;
                }
            } else {
                closetHoldSeconds = 0;
            }
        } else {
            if (!interactKeyHeld) {
                closetHoldSeconds = 0;
            }
            if (!interactKeyHeld || !bedGroupRef) {
                bedHoldSeconds = 0;
            }
        }
        updateMovement(dt);
        updatePhases(dt);
        updateNightmareMode(dt);
        updateInteractPrompt();
        updateFlashlight();
        updatePhone(dt);
        updateHorrorGrain();
        updateSanityIndicator();
        updateScaryAmbientEffects(dt);
    }

    renderer.render(scene, camera);
}

function startGame(mode = 'normal') {
    if (gameStartInProgress) return;
    if (mode === 'nightmare' && !isNightmareModeUnlocked()) {
        updateMenuProgressText();
        return;
    }
    gameStartInProgress = true;
    loadingSkipRequested = false;
    loadingRunToken += 1;
    const token = loadingRunToken;

    configureGameMode(mode);
    buildFlashlight();
    resetNightmareRunState();
    audioCtx.resume();
    applySettings();
    inventory = [];
    gameboyHeld = false;
    gameboyActive = false;
    gamePaused = false;
    sanityLevel = 100;
    scaryAmbientTimer = 0;
    furnitureShiftTimer = 0;
    breathingEffectTimer = 0;
    if (gameboyMesh) gameboyMesh.visible = true;
    renderInventoryBar();
    setPauseState(false);
    closeGameBoy();
    runStartupLoadingSequence(token).catch(() => {
        if (token !== loadingRunToken) return;
        beginGameplayAfterLoading(token);
    });
}

document.addEventListener('keydown', (e) => {
    if (gamePaused) return;
    if (e.code === 'KeyF' && flashlightHeld) {
        if (nightmareActive && blackoutTriggered && flashlightBattery <= 0.001) {
            showDialogue(nightmareActive ? "The lantern is out of fluid." : "The flashlight battery is dead.", 2000);
            return;
        }
        flashlightOn = !flashlightOn;
        showDialogue(flashlightOn ? (nightmareActive ? "Lantern on." : "Flashlight on.") : (nightmareActive ? "Lantern off." : "Flashlight off."), 1200);
        updateBatteryHud();
    }
});

const subtitlesToggleEl = document.getElementById('setting-subtitles');
const voiceToggleEl = document.getElementById('setting-voice');
const skipLoadingToggleEl = document.getElementById('setting-skip-loading');
const photosensitiveToggleEl = document.getElementById('setting-photosensitive');
const reducedFlashingToggleEl = document.getElementById('setting-reduced-flashing');
const volumeSliderEl = document.getElementById('setting-volume');
if (subtitlesToggleEl) {
    subtitlesToggleEl.addEventListener('change', (e) => {
        gameSettings.subtitles = !!e.target.checked;
        applySettings();
    });
}
if (voiceToggleEl) {
    voiceToggleEl.addEventListener('change', (e) => {
        gameSettings.voice = !!e.target.checked;
        applySettings();
    });
}
if (skipLoadingToggleEl) {
    skipLoadingToggleEl.addEventListener('change', (e) => {
        gameSettings.autoSkipLoading = !!e.target.checked;
        applySettings();
    });
}
if (photosensitiveToggleEl) {
    photosensitiveToggleEl.addEventListener('change', (e) => {
        gameSettings.photosensitiveSafeMode = !!e.target.checked;
        if (gameSettings.photosensitiveSafeMode) {
            gameSettings.reducedFlashing = true;
        }
        applySettings();
    });
}
if (reducedFlashingToggleEl) {
    reducedFlashingToggleEl.addEventListener('change', (e) => {
        gameSettings.reducedFlashing = !!e.target.checked;
        applySettings();
    });
}
if (volumeSliderEl) {
    volumeSliderEl.addEventListener('input', (e) => {
        const v = Number(e.target.value);
        gameSettings.masterVolume = Number.isFinite(v) ? Math.max(0, Math.min(1, v)) : 0.8;
        applySettings();
    });
}
const fovSliderEl = document.getElementById('setting-fov');
if (fovSliderEl) {
    fovSliderEl.addEventListener('input', (e) => {
        gameSettings.fov = Number(e.target.value);
        applySettings();
    });
}
const sensSliderEl = document.getElementById('setting-sens');
if (sensSliderEl) {
    sensSliderEl.addEventListener('input', (e) => {
        gameSettings.sensitivity = Number(e.target.value);
        applySettings();
    });
}
document.querySelectorAll('.quality-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        gameSettings.quality = btn.dataset.q;
        applySettings();
    });
});
const loadingSkipBtnEl = document.getElementById('loading-skip-btn');
if (loadingSkipBtnEl) {
    loadingSkipBtnEl.addEventListener('click', () => {
        if (!gameStartInProgress) return;
        loadingSkipRequested = true;
        loadingSkipBtnEl.disabled = true;
        updateLoadingPanel(loadingProgressValue + 0.02, 'Skipping preload...');
    });
}
applySettingsToUI();
updateMenuProgressText();

init();
animate();
</script>
</body>
</html>
